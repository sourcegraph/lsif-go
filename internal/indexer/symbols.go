package indexer

import (
	"fmt"
	"go/ast"
	"go/token"
	"strings"

	"github.com/hashicorp/go-multierror"
	"github.com/pkg/errors"
	"github.com/sourcegraph/sourcegraph/enterprise/lib/codeintel/lsif/protocol"
	"golang.org/x/tools/go/packages"
)

func (i *Indexer) indexSymbols() error {
	s := &symbolIndexer{i: i}
	var errs error
	i.visitEachPackage("Indexing symbols", func(p *packages.Package) {
		err := s.indexPackage(p)
		if err != nil {
			errs = multierror.Append(errs, errors.Wrap(err, "package "+p.Name))
		}
	})
	return errs
}

type symbolIndexer struct {
	i *Indexer
}

// indexPackage indexes a single Go package, emitting the LSIF data associated with the
// textDocument/documentSymbol LSP request:
// https://microsoft.github.io/language-server-protocol/specifications/lsif/0.5.0/specification/#documentSymbol
//
// See this section of the LSIF spec for a more detailed explanation:
// https://microsoft.github.io/language-server-protocol/specifications/lsif/0.5.0/specification/#documentSymbol
//
// Note that Sourcegraph has a custom LSIF spec extension on `RangeTag` which we implement here:
// https://sourcegraph.com/github.com/sourcegraph/sourcegraph@8b6320aef598e670cee73cfe0f4c876a6c0d0632/-/blob/enterprise/lib/codeintel/lsif/protocol/range.go#L24-25
//
// The custom extension gives us the ability to denote if a symbol is deprecated, exported, or unexported.
//
// Conceptually, when looking at this code you should know the following:
//
// * All symbols hierarchies are rooted below a _document_ (textDocument/documentSymbol is document based.)
// * Top-level Go variables, functions, types, constants, etc. are children of the root document.
// * Methods are children of their receiver type.
//
// The hierarchy of symbols is represented by `DocumentSymbolResult` in the LSP spec, because we
// generate `RangeBasedDocumentSymbol` results we are able to utilize the `children` property which
// effectively gives us a hierarchy. Information about symbols (symbol name, docstrings, type, etc)
// is emitted via `RangeTag`s which correspond to the `RangeBasedDocumentSymbol`.
func (s *symbolIndexer) indexPackage(p *packages.Package) error {
	for _, file := range p.Syntax {
		filename := p.Fset.Position(file.Pos()).Filename
		if !strings.HasPrefix(filename, s.i.projectRoot) {
			// Omit files (such as those generated by `go test`) that aren't in the project root
			// because those are not externally accessible.
			continue
		}
		if err := s.indexFile(p, file); err != nil {
			return errors.Wrap(err, "file "+filename)
		}
	}
	return nil
}

// indexFile emits the `RangeBasedDocumentSymbol` corresponding to the root of the document `f`,
// under which all symbols in a file are nested.
func (s *symbolIndexer) indexFile(p *packages.Package, f *ast.File) error {
	// The "root" document symbol, corresponding to the file itself. All symbols in a file are
	// nested below here.
	document := &protocol.RangeBasedDocumentSymbol{}

	// Visit each node the AST, emitting `RangeBasedDocumentSymbol` for each node we're
	// interested in.
	var firstErr error
	var visitor ast.Visitor
	visitor = visitorFunc(func(n ast.Node) (w ast.Visitor) {
		switch node := n.(type) {
		//case *ast.TypeSpec:
		// Struct, interace, and other type definitions.
		case *ast.GenDecl:
			// Constants, variables
			if node.Tok == token.CONST || node.Tok == token.VAR {
				symbolKind := protocol.Constant
				if node.Tok == token.VAR {
					symbolKind = protocol.Variable
				}
				for _, name := range specNames(node.Specs) {
					if name == "_" {
						// Ignore `const _ T = foo` assignments: they cannot be referred to at all.
						continue
					}
					child, err := s.indexSymbol(p, f, name, "", "", symbolKind, declNamePos(node, name))
					if err != nil {
						firstErr = errors.Wrap(err, "symbol "+name)
						return nil
					}
					document.Children = append(document.Children, child)
				}
			}
			//case *ast.FuncDecl:
			// Functions, methods
		}
		return visitor
	})
	ast.Walk(visitor, f)
	if firstErr != nil {
		return firstErr
	}

	// Emit the edge for the document itself.
	document.ID = s.i.emitRangeForSymbol(p.Fset.Position(f.Name.Pos()), len(f.Name.Name), &protocol.RangeTag{
		Type:   "definition",
		Text:   p.PkgPath,
		Detail: "file doc text", // TODO(slimsag): file.Doc.Text(),
		Kind:   protocol.Package,
		// TODO(slimsag): should exported status depend on whether or not file contains exported items?
		Tags: []protocol.SymbolTag{protocol.Exported},
	})
	filename := p.Fset.Position(f.Pos()).Filename
	doc := s.i.documents[filename]
	if doc == nil {
		return fmt.Errorf("(unexpected) document not found after indexing: %s", filename)
	}
	results := []*protocol.RangeBasedDocumentSymbol{document}
	resultID := s.i.emitter.EmitDocumentSymbolResult(results)
	s.i.emitter.EmitDocumentSymbolEdge(resultID, doc.DocumentID)
	return nil
}

// indexSymbol emits the `RangeBasedDocumentSymbol` corresponding to the given singular symbol.
// e.g., a variable, constant, function, method, type, field, etc.
//
// * name is the name of the symbol
// * recv is the name of the Go receiver (e.g. struct), or an empty string.
// * container is the name of the container (e.g. struct or interface name), if any.
//
func (s *symbolIndexer) indexSymbol(
	p *packages.Package,
	f *ast.File,
	name, recv, container string,
	kind protocol.SymbolKind,
	pos token.Pos,
) (*protocol.RangeBasedDocumentSymbol, error) {
	sym := &protocol.RangeBasedDocumentSymbol{}
	sym.ID = s.i.emitRangeForSymbol(p.Fset.Position(pos), len(name), &protocol.RangeTag{
		Type: "definition",
		Text: name,
		Kind: protocol.Constant,
	})
	return sym, nil
}

// visitorFunc is a function which implements the ast.Visitor interface.
type visitorFunc func(ast.Node) ast.Visitor

func (v visitorFunc) Visit(n ast.Node) ast.Visitor {
	return v(n)
}

func recvString(recv ast.Expr) string {
	switch t := recv.(type) {
	case *ast.Ident:
		return t.Name
	case *ast.StarExpr:
		return "*" + recvString(t.X)
	}
	return "BADRECV"
}

func specNames(specs []ast.Spec) []string {
	names := make([]string, 0, len(specs))
	for _, s := range specs {
		// s guaranteed to be an *ast.ValueSpec by readValue
		for _, ident := range s.(*ast.ValueSpec).Names {
			names = append(names, ident.Name)
		}
	}
	return names
}

func declNamePos(decl *ast.GenDecl, name string) token.Pos {
	for _, spec := range decl.Specs {
		switch spec := spec.(type) {
		case *ast.ImportSpec:
			if spec.Name != nil {
				return spec.Name.Pos()
			}
			return spec.Path.Pos()
		case *ast.ValueSpec:
			for _, specName := range spec.Names {
				if specName.Name == name {
					return specName.NamePos
				}
			}
		case *ast.TypeSpec:
			return spec.Name.Pos()
		}
	}
	return decl.TokPos
}

func isExported(containerName, name string) bool {
	if containerName == "" {
		return ast.IsExported(name)
	}
	return ast.IsExported(containerName) && ast.IsExported(name)
}
