# <a name="">Index <small>(new page,exported)</small></a>

# Index

- [Package regexp](#regexp)
- [Package syntax](#syntax)
- [Package regexp_test](#regexp_test)

## <a name="regexp">Package regexp <small>(new page,exported)</small></a>

Package regexp implements regular expression search. 

The syntax of the regular expressions accepted is the same general syntax used by Perl, Python, and other languages. More precisely, it is the syntax accepted by RE2 and described at [https://golang.org/s/re2syntax](https://golang.org/s/re2syntax), except for \C. For an overview of the syntax, run 

```
go doc regexp/syntax

```
The regexp implementation provided by this package is guaranteed to run in time linear in the size of the input. (This is a property not guaranteed by most open source implementations of regular expressions.) For more information about this property, see 

```
[https://swtch.com/~rsc/regexp/regexp1.html](https://swtch.com/~rsc/regexp/regexp1.html)

```
or any book about automata theory. 

All characters are UTF-8-encoded code points. 

There are 16 methods of Regexp that match a regular expression and identify the matched text. Their names are matched by this regular expression: 

```
Find(All)?(String)?(Submatch)?(Index)?

```
If 'All' is present, the routine matches successive non-overlapping matches of the entire expression. Empty matches abutting a preceding match are ignored. The return value is a slice containing the successive return values of the corresponding non-'All' routine. These routines take an extra integer argument, n. If n >= 0, the function returns at most n matches/submatches; otherwise, it returns all of them. 

If 'String' is present, the argument is a string; otherwise it is a slice of bytes; return values are adjusted as appropriate. 

If 'Submatch' is present, the return value is a slice identifying the successive submatches of the expression. Submatches are matches of parenthesized subexpressions (also known as capturing groups) within the regular expression, numbered from left to right in order of opening parenthesis. Submatch 0 is the match of the entire expression, submatch 1 the match of the first parenthesized subexpression, and so on. 

If 'Index' is present, matches and submatches are identified by byte index pairs within the input string: result[2*n:2*n+1] identifies the indexes of the nth submatch. The pair for n==0 identifies the match of the entire expression. If 'Index' is not present, the match is identified by the text of the match/submatch. If an index is negative or text is nil, it means that subexpression did not match any string in the input. For 'String' versions an empty string means either no match or an empty match. 

There is also a subset of the methods that can be applied to text read from a RuneReader: 

```
MatchReader, FindReaderIndex, FindReaderSubmatchIndex

```
This set may grow. Note that regular expression matches may need to examine text beyond the text returned by a match, so the methods that match text from a RuneReader may read arbitrarily far into the input before returning. 

(There are a few other methods that do not match this pattern.) 

## Index

- [Constants](#regexp-const)
  - [const visitedBits](#regexp-const-visitedBits)
  - [const maxBacktrackProg](#regexp-const-maxBacktrackProg)
  - [const maxBacktrackVector](#regexp-const-maxBacktrackVector)
  - [const mergeFailed](#regexp-const-mergeFailed)
  - [const endOfText](#regexp-const-endOfText)
  - [const startSize](#regexp-const-startSize)
- [Variables](#regexp-var)
  - [var bitStatePool](#regexp-var-bitStatePool)
  - [var t](#regexp-var-t)
  - [var flag](#regexp-var-flag)
  - [var onePassPool](#regexp-var-onePassPool)
  - [var flag](#regexp-var-flag)
  - [var arrayNoInts](#regexp-var-arrayNoInts)
  - [var buf](#regexp-var-buf)
  - [var noRune](#regexp-var-noRune)
  - [var noNext](#regexp-var-noNext)
  - [var lx](#regexp-var-lx)
  - [var rx](#regexp-var-rx)
  - [var anyRuneNotNL](#regexp-var-anyRuneNotNL)
  - [var anyRune](#regexp-var-anyRune)
  - [var instQueue](#regexp-var-instQueue)
  - [var visitQueue](#regexp-var-visitQueue)
  - [var check](#regexp-var-check)
  - [var onePassRunes](#regexp-var-onePassRunes)
  - [var matchSize](#regexp-var-matchSize)
  - [var matchPool](#regexp-var-matchPool)
  - [var lnext](#regexp-var-lnext)
  - [var buf](#regexp-var-buf)
  - [var endPos](#regexp-var-endPos)
  - [var dstCap](#regexp-var-dstCap)
  - [var width](#regexp-var-width)
  - [var specialBytes](#regexp-var-specialBytes)
  - [var i](#regexp-var-i)
  - [var end](#regexp-var-end)
  - [var width](#regexp-var-width)
  - [var dstCap](#regexp-var-dstCap)
  - [var dstCap](#regexp-var-dstCap)
  - [var dstCap](#regexp-var-dstCap)
  - [var dstCap](#regexp-var-dstCap)
  - [var result](#regexp-var-result)
  - [var result](#regexp-var-result)
  - [var result](#regexp-var-result)
  - [var result](#regexp-var-result)
  - [var result](#regexp-var-result)
  - [var result](#regexp-var-result)
  - [var result](#regexp-var-result)
  - [var result](#regexp-var-result)
  - [var goodRe](#regexp-var-goodRe)
  - [var badRe](#regexp-var-badRe)
  - [var replaceTests](#regexp-var-replaceTests)
  - [var replaceLiteralTests](#regexp-var-replaceLiteralTests)
  - [var replaceFuncTests](#regexp-var-replaceFuncTests)
  - [var metaTests](#regexp-var-metaTests)
  - [var literalPrefixTests](#regexp-var-literalPrefixTests)
  - [var emptySubexpIndices](#regexp-var-emptySubexpIndices)
  - [var subexpCases](#regexp-var-subexpCases)
  - [var splitTests](#regexp-var-splitTests)
  - [var sink](#regexp-var-sink)
  - [var compileBenchData](#regexp-var-compileBenchData)
  - [var minInputLenTests](#regexp-var-minInputLenTests)
  - [var txt](#regexp-var-txt)
  - [var str](#regexp-var-str)
  - [var input](#regexp-var-input)
  - [var inStrings](#regexp-var-inStrings)
  - [var re](#regexp-var-re)
  - [var refull](#regexp-var-refull)
  - [var nfail](#regexp-var-nfail)
  - [var ncase](#regexp-var-ncase)
  - [var text](#regexp-var-text)
  - [var run](#regexp-var-run)
  - [var match](#regexp-var-match)
  - [var notab](#regexp-var-notab)
  - [var x](#regexp-var-x)
  - [var end](#regexp-var-end)
  - [var v](#regexp-var-v)
  - [var err](#regexp-var-err)
  - [var text](#regexp-var-text)
  - [var benchData](#regexp-var-benchData)
  - [var benchSizes](#regexp-var-benchSizes)
  - [var findTests](#regexp-var-findTests)
  - [var runeMergeTests](#regexp-var-runeMergeTests)
  - [var onePassTests](#regexp-var-onePassTests)
  - [var p](#regexp-var-p)
  - [var re](#regexp-var-re)
  - [var err](#regexp-var-err)
  - [var onePassTests1](#regexp-var-onePassTests1)
- [Types](#regexp-type)
  - [type job struct](#regexp-type-job)
  - [type bitState struct](#regexp-type-bitState)
    - [func newBitState() *bitState](#regexp-type-bitState-newBitState)
    - [func (b *bitState) reset(prog *syntax.Prog, end int, ncap int)](#regexp-type-bitState-reset)
    - [func (b *bitState) shouldVisit(pc uint32, pos int) bool](#regexp-type-bitState-shouldVisit)
    - [func (b *bitState) push(re *Regexp, pc uint32, pos int, arg bool)](#regexp-type-bitState-push)
  - [type queue struct](#regexp-type-queue)
  - [type entry struct](#regexp-type-entry)
  - [type thread struct](#regexp-type-thread)
  - [type machine struct](#regexp-type-machine)
    - [func (m *machine) init(ncap int)](#regexp-type-machine-init)
    - [func (m *machine) alloc(i *syntax.Inst) *thread](#regexp-type-machine-alloc)
    - [func (m *machine) match(i input, pos int) bool](#regexp-type-machine-match)
    - [func (m *machine) clear(q *queue)](#regexp-type-machine-clear)
    - [func (m *machine) step(runq, nextq *queue, pos, nextPos int, c rune, nextCond *lazyFlag)](#regexp-type-machine-step)
    - [func (m *machine) add(q *queue, pc uint32, pos int, cap []int, cond *lazyFlag, t *thread) *thread](#regexp-type-machine-add)
  - [type inputs struct](#regexp-type-inputs)
    - [func (i *inputs) newBytes(b []byte) input](#regexp-type-inputs-newBytes)
    - [func (i *inputs) newString(s string) input](#regexp-type-inputs-newString)
    - [func (i *inputs) newReader(r io.RuneReader) input](#regexp-type-inputs-newReader)
    - [func (i *inputs) clear()](#regexp-type-inputs-clear)
    - [func (i *inputs) init(r io.RuneReader, b []byte, s string) (input, int)](#regexp-type-inputs-init)
  - [type lazyFlag uint64](#regexp-type-lazyFlag)
    - [func newLazyFlag(r1, r2 rune) lazyFlag](#regexp-type-lazyFlag-newLazyFlag)
    - [func (f lazyFlag) match(op syntax.EmptyOp) bool](#regexp-type-lazyFlag-match)
  - [type onePassMachine struct](#regexp-type-onePassMachine)
    - [func newOnePassMachine() *onePassMachine](#regexp-type-onePassMachine-newOnePassMachine)
  - [type onePassProg struct](#regexp-type-onePassProg)
    - [func onePassCopy(prog *syntax.Prog) *onePassProg](#regexp-type-onePassProg-onePassCopy)
    - [func makeOnePass(p *onePassProg) *onePassProg](#regexp-type-onePassProg-makeOnePass)
    - [func compileOnePass(prog *syntax.Prog) (p *onePassProg)](#regexp-type-onePassProg-compileOnePass)
  - [type onePassInst struct](#regexp-type-onePassInst)
  - [type queueOnePass struct](#regexp-type-queueOnePass)
    - [func newQueue(size int) (q *queueOnePass)](#regexp-type-queueOnePass-newQueue)
    - [func (q *queueOnePass) empty() bool](#regexp-type-queueOnePass-empty)
    - [func (q *queueOnePass) next() (n uint32)](#regexp-type-queueOnePass-next)
    - [func (q *queueOnePass) clear()](#regexp-type-queueOnePass-clear)
    - [func (q *queueOnePass) contains(u uint32) bool](#regexp-type-queueOnePass-contains)
    - [func (q *queueOnePass) insert(u uint32)](#regexp-type-queueOnePass-insert)
    - [func (q *queueOnePass) insertNew(u uint32)](#regexp-type-queueOnePass-insertNew)
  - [type runeSlice []rune](#regexp-type-runeSlice)
    - [func (p runeSlice) Len() int](#regexp-type-runeSlice-Len)
    - [func (p runeSlice) Less(i, j int) bool](#regexp-type-runeSlice-Less)
    - [func (p runeSlice) Swap(i, j int)](#regexp-type-runeSlice-Swap)
  - [type Regexp struct](#regexp-type-Regexp)
    - [func Compile(expr string) (*Regexp, error)](#regexp-type-Regexp-Compile)
    - [func CompilePOSIX(expr string) (*Regexp, error)](#regexp-type-Regexp-CompilePOSIX)
    - [func compile(expr string, mode syntax.Flags, longest bool) (*Regexp, error)](#regexp-type-Regexp-compile)
    - [func MustCompile(str string) *Regexp](#regexp-type-Regexp-MustCompile)
    - [func MustCompilePOSIX(str string) *Regexp](#regexp-type-Regexp-MustCompilePOSIX)
    - [func compileTest(t *testing.T, expr string, error string) *Regexp](#regexp-type-Regexp-compileTest)
    - [func tryCompile(s string) (re *Regexp, err error)](#regexp-type-Regexp-tryCompile)
    - [func (re *Regexp) tryBacktrack(b *bitState, i input, pc uint32, pos int) bool](#regexp-type-Regexp-tryBacktrack)
    - [func (re *Regexp) backtrack(ib []byte, is string, pos int, ncap int, dstCap []int) []int](#regexp-type-Regexp-backtrack)
    - [func (re *Regexp) doOnePass(ir io.RuneReader, ib []byte, is string, pos, ncap int, dstCap []int) []int](#regexp-type-Regexp-doOnePass)
    - [func (re *Regexp) doMatch(r io.RuneReader, b []byte, s string) bool](#regexp-type-Regexp-doMatch)
    - [func (re *Regexp) doExecute(r io.RuneReader, b []byte, s string, pos int, ncap int, dstCap []int) []int](#regexp-type-Regexp-doExecute)
    - [func (re *Regexp) String() string](#regexp-type-Regexp-String)
    - [func (re *Regexp) Copy() *Regexp](#regexp-type-Regexp-Copy)
    - [func (re *Regexp) Longest()](#regexp-type-Regexp-Longest)
    - [func (re *Regexp) get() *machine](#regexp-type-Regexp-get)
    - [func (re *Regexp) put(m *machine)](#regexp-type-Regexp-put)
    - [func (re *Regexp) NumSubexp() int](#regexp-type-Regexp-NumSubexp)
    - [func (re *Regexp) SubexpNames() []string](#regexp-type-Regexp-SubexpNames)
    - [func (re *Regexp) SubexpIndex(name string) int](#regexp-type-Regexp-SubexpIndex)
    - [func (re *Regexp) LiteralPrefix() (prefix string, complete bool)](#regexp-type-Regexp-LiteralPrefix)
    - [func (re *Regexp) MatchReader(r io.RuneReader) bool](#regexp-type-Regexp-MatchReader)
    - [func (re *Regexp) MatchString(s string) bool](#regexp-type-Regexp-MatchString)
    - [func (re *Regexp) Match(b []byte) bool](#regexp-type-Regexp-Match)
    - [func (re *Regexp) ReplaceAllString(src, repl string) string](#regexp-type-Regexp-ReplaceAllString)
    - [func (re *Regexp) ReplaceAllLiteralString(src, repl string) string](#regexp-type-Regexp-ReplaceAllLiteralString)
    - [func (re *Regexp) ReplaceAllStringFunc(src string, repl func(string) string) string](#regexp-type-Regexp-ReplaceAllStringFunc)
    - [func (re *Regexp) replaceAll(bsrc []byte, src string, nmatch int, repl func(dst []byte, m []int) []byte) []byte](#regexp-type-Regexp-replaceAll)
    - [func (re *Regexp) ReplaceAll(src, repl []byte) []byte](#regexp-type-Regexp-ReplaceAll)
    - [func (re *Regexp) ReplaceAllLiteral(src, repl []byte) []byte](#regexp-type-Regexp-ReplaceAllLiteral)
    - [func (re *Regexp) ReplaceAllFunc(src []byte, repl func([]byte) []byte) []byte](#regexp-type-Regexp-ReplaceAllFunc)
    - [func (re *Regexp) pad(a []int) []int](#regexp-type-Regexp-pad)
    - [func (re *Regexp) allMatches(s string, b []byte, n int, deliver func([]int))](#regexp-type-Regexp-allMatches)
    - [func (re *Regexp) Find(b []byte) []byte](#regexp-type-Regexp-Find)
    - [func (re *Regexp) FindIndex(b []byte) (loc []int)](#regexp-type-Regexp-FindIndex)
    - [func (re *Regexp) FindString(s string) string](#regexp-type-Regexp-FindString)
    - [func (re *Regexp) FindStringIndex(s string) (loc []int)](#regexp-type-Regexp-FindStringIndex)
    - [func (re *Regexp) FindReaderIndex(r io.RuneReader) (loc []int)](#regexp-type-Regexp-FindReaderIndex)
    - [func (re *Regexp) FindSubmatch(b []byte) [][]byte](#regexp-type-Regexp-FindSubmatch)
    - [func (re *Regexp) Expand(dst []byte, template []byte, src []byte, match []int) []byte](#regexp-type-Regexp-Expand)
    - [func (re *Regexp) ExpandString(dst []byte, template string, src string, match []int) []byte](#regexp-type-Regexp-ExpandString)
    - [func (re *Regexp) expand(dst []byte, template string, bsrc []byte, src string, match []int) []byte](#regexp-type-Regexp-expand)
    - [func (re *Regexp) FindSubmatchIndex(b []byte) []int](#regexp-type-Regexp-FindSubmatchIndex)
    - [func (re *Regexp) FindStringSubmatch(s string) []string](#regexp-type-Regexp-FindStringSubmatch)
    - [func (re *Regexp) FindStringSubmatchIndex(s string) []int](#regexp-type-Regexp-FindStringSubmatchIndex)
    - [func (re *Regexp) FindReaderSubmatchIndex(r io.RuneReader) []int](#regexp-type-Regexp-FindReaderSubmatchIndex)
    - [func (re *Regexp) FindAll(b []byte, n int) [][]byte](#regexp-type-Regexp-FindAll)
    - [func (re *Regexp) FindAllIndex(b []byte, n int) [][]int](#regexp-type-Regexp-FindAllIndex)
    - [func (re *Regexp) FindAllString(s string, n int) []string](#regexp-type-Regexp-FindAllString)
    - [func (re *Regexp) FindAllStringIndex(s string, n int) [][]int](#regexp-type-Regexp-FindAllStringIndex)
    - [func (re *Regexp) FindAllSubmatch(b []byte, n int) [][][]byte](#regexp-type-Regexp-FindAllSubmatch)
    - [func (re *Regexp) FindAllSubmatchIndex(b []byte, n int) [][]int](#regexp-type-Regexp-FindAllSubmatchIndex)
    - [func (re *Regexp) FindAllStringSubmatch(s string, n int) [][]string](#regexp-type-Regexp-FindAllStringSubmatch)
    - [func (re *Regexp) FindAllStringSubmatchIndex(s string, n int) [][]int](#regexp-type-Regexp-FindAllStringSubmatchIndex)
    - [func (re *Regexp) Split(s string, n int) []string](#regexp-type-Regexp-Split)
  - [type input interface](#regexp-type-input)
  - [type inputString struct](#regexp-type-inputString)
    - [func (i *inputString) step(pos int) (rune, int)](#regexp-type-inputString-step)
    - [func (i *inputString) canCheckPrefix() bool](#regexp-type-inputString-canCheckPrefix)
    - [func (i *inputString) hasPrefix(re *Regexp) bool](#regexp-type-inputString-hasPrefix)
    - [func (i *inputString) index(re *Regexp, pos int) int](#regexp-type-inputString-index)
    - [func (i *inputString) context(pos int) lazyFlag](#regexp-type-inputString-context)
  - [type inputBytes struct](#regexp-type-inputBytes)
    - [func (i *inputBytes) step(pos int) (rune, int)](#regexp-type-inputBytes-step)
    - [func (i *inputBytes) canCheckPrefix() bool](#regexp-type-inputBytes-canCheckPrefix)
    - [func (i *inputBytes) hasPrefix(re *Regexp) bool](#regexp-type-inputBytes-hasPrefix)
    - [func (i *inputBytes) index(re *Regexp, pos int) int](#regexp-type-inputBytes-index)
    - [func (i *inputBytes) context(pos int) lazyFlag](#regexp-type-inputBytes-context)
  - [type inputReader struct](#regexp-type-inputReader)
    - [func (i *inputReader) step(pos int) (rune, int)](#regexp-type-inputReader-step)
    - [func (i *inputReader) canCheckPrefix() bool](#regexp-type-inputReader-canCheckPrefix)
    - [func (i *inputReader) hasPrefix(re *Regexp) bool](#regexp-type-inputReader-hasPrefix)
    - [func (i *inputReader) index(re *Regexp, pos int) int](#regexp-type-inputReader-index)
    - [func (i *inputReader) context(pos int) lazyFlag](#regexp-type-inputReader-context)
  - [type stringError struct](#regexp-type-stringError)
  - [type ReplaceTest struct](#regexp-type-ReplaceTest)
  - [type ReplaceFuncTest struct](#regexp-type-ReplaceFuncTest)
  - [type MetaTest struct](#regexp-type-MetaTest)
  - [type subexpIndex struct](#regexp-type-subexpIndex)
  - [type subexpCase struct](#regexp-type-subexpCase)
  - [type FindTest struct](#regexp-type-FindTest)
    - [func (t FindTest) String() string](#regexp-type-FindTest-String)
- [Functions](#regexp-func)
  - [func freeBitState(b *bitState)](#regexp-func-freeBitState)
  - [func maxBitStateLen(prog *syntax.Prog) int](#regexp-func-maxBitStateLen)
  - [func shouldBacktrack(prog *syntax.Prog) bool](#regexp-func-shouldBacktrack)
  - [func freeOnePassMachine(m *onePassMachine)](#regexp-func-freeOnePassMachine)
  - [func onePassPrefix(p *syntax.Prog) (prefix string, complete bool, pc uint32)](#regexp-func-onePassPrefix)
  - [func onePassNext(i *onePassInst, r rune) uint32](#regexp-func-onePassNext)
  - [func iop(i *syntax.Inst) syntax.InstOp](#regexp-func-iop)
  - [func mergeRuneSets(leftRunes, rightRunes *[]rune, leftPC, rightPC uint32) ([]rune, []uint32)](#regexp-func-mergeRuneSets)
  - [func cleanupOnePass(prog *onePassProg, original *syntax.Prog)](#regexp-func-cleanupOnePass)
  - [func minInputLen(re *syntax.Regexp) int](#regexp-func-minInputLen)
  - [func quote(s string) string](#regexp-func-quote)
  - [func MatchReader(pattern string, r io.RuneReader) (matched bool, err error)](#regexp-func-MatchReader)
  - [func MatchString(pattern string, s string) (matched bool, err error)](#regexp-func-MatchString)
  - [func Match(pattern string, b []byte) (matched bool, err error)](#regexp-func-Match)
  - [func special(b byte) bool](#regexp-func-special)
  - [func init()](#regexp-func-init)
  - [func QuoteMeta(s string) string](#regexp-func-QuoteMeta)
  - [func extract(str string) (name string, num int, rest string, ok bool)](#regexp-func-extract)
  - [func TestGoodCompile(t *testing.T)](#regexp-func-TestGoodCompile)
  - [func TestBadCompile(t *testing.T)](#regexp-func-TestBadCompile)
  - [func matchTest(t *testing.T, test *FindTest)](#regexp-func-matchTest)
  - [func TestMatch(t *testing.T)](#regexp-func-TestMatch)
  - [func matchFunctionTest(t *testing.T, test *FindTest)](#regexp-func-matchFunctionTest)
  - [func TestMatchFunction(t *testing.T)](#regexp-func-TestMatchFunction)
  - [func copyMatchTest(t *testing.T, test *FindTest)](#regexp-func-copyMatchTest)
  - [func TestCopyMatch(t *testing.T)](#regexp-func-TestCopyMatch)
  - [func TestReplaceAll(t *testing.T)](#regexp-func-TestReplaceAll)
  - [func TestReplaceAllLiteral(t *testing.T)](#regexp-func-TestReplaceAllLiteral)
  - [func TestReplaceAllFunc(t *testing.T)](#regexp-func-TestReplaceAllFunc)
  - [func TestQuoteMeta(t *testing.T)](#regexp-func-TestQuoteMeta)
  - [func TestLiteralPrefix(t *testing.T)](#regexp-func-TestLiteralPrefix)
  - [func TestSubexp(t *testing.T)](#regexp-func-TestSubexp)
  - [func TestSplit(t *testing.T)](#regexp-func-TestSplit)
  - [func TestParseAndCompile(t *testing.T)](#regexp-func-TestParseAndCompile)
  - [func TestOnePassCutoff(t *testing.T)](#regexp-func-TestOnePassCutoff)
  - [func TestSwitchBacktrack(t *testing.T)](#regexp-func-TestSwitchBacktrack)
  - [func BenchmarkFind(b *testing.B)](#regexp-func-BenchmarkFind)
  - [func BenchmarkFindAllNoMatches(b *testing.B)](#regexp-func-BenchmarkFindAllNoMatches)
  - [func BenchmarkFindString(b *testing.B)](#regexp-func-BenchmarkFindString)
  - [func BenchmarkFindSubmatch(b *testing.B)](#regexp-func-BenchmarkFindSubmatch)
  - [func BenchmarkFindStringSubmatch(b *testing.B)](#regexp-func-BenchmarkFindStringSubmatch)
  - [func BenchmarkLiteral(b *testing.B)](#regexp-func-BenchmarkLiteral)
  - [func BenchmarkNotLiteral(b *testing.B)](#regexp-func-BenchmarkNotLiteral)
  - [func BenchmarkMatchClass(b *testing.B)](#regexp-func-BenchmarkMatchClass)
  - [func BenchmarkMatchClass_InRange(b *testing.B)](#regexp-func-BenchmarkMatchClass_InRange)
  - [func BenchmarkReplaceAll(b *testing.B)](#regexp-func-BenchmarkReplaceAll)
  - [func BenchmarkAnchoredLiteralShortNonMatch(b *testing.B)](#regexp-func-BenchmarkAnchoredLiteralShortNonMatch)
  - [func BenchmarkAnchoredLiteralLongNonMatch(b *testing.B)](#regexp-func-BenchmarkAnchoredLiteralLongNonMatch)
  - [func BenchmarkAnchoredShortMatch(b *testing.B)](#regexp-func-BenchmarkAnchoredShortMatch)
  - [func BenchmarkAnchoredLongMatch(b *testing.B)](#regexp-func-BenchmarkAnchoredLongMatch)
  - [func BenchmarkOnePassShortA(b *testing.B)](#regexp-func-BenchmarkOnePassShortA)
  - [func BenchmarkNotOnePassShortA(b *testing.B)](#regexp-func-BenchmarkNotOnePassShortA)
  - [func BenchmarkOnePassShortB(b *testing.B)](#regexp-func-BenchmarkOnePassShortB)
  - [func BenchmarkNotOnePassShortB(b *testing.B)](#regexp-func-BenchmarkNotOnePassShortB)
  - [func BenchmarkOnePassLongPrefix(b *testing.B)](#regexp-func-BenchmarkOnePassLongPrefix)
  - [func BenchmarkOnePassLongNotPrefix(b *testing.B)](#regexp-func-BenchmarkOnePassLongNotPrefix)
  - [func BenchmarkMatchParallelShared(b *testing.B)](#regexp-func-BenchmarkMatchParallelShared)
  - [func BenchmarkMatchParallelCopied(b *testing.B)](#regexp-func-BenchmarkMatchParallelCopied)
  - [func BenchmarkQuoteMetaAll(b *testing.B)](#regexp-func-BenchmarkQuoteMetaAll)
  - [func BenchmarkQuoteMetaNone(b *testing.B)](#regexp-func-BenchmarkQuoteMetaNone)
  - [func BenchmarkCompile(b *testing.B)](#regexp-func-BenchmarkCompile)
  - [func TestDeepEqual(t *testing.T)](#regexp-func-TestDeepEqual)
  - [func TestMinInputLen(t *testing.T)](#regexp-func-TestMinInputLen)
  - [func TestRE2Exhaustive(t *testing.T)](#regexp-func-TestRE2Exhaustive)
  - [func TestRE2Search(t *testing.T)](#regexp-func-TestRE2Search)
  - [func testRE2(t *testing.T, file string)](#regexp-func-testRE2)
  - [func runFull(re, refull *Regexp, text string) ([]int, string)](#regexp-func-runFull)
  - [func runPartial(re, refull *Regexp, text string) ([]int, string)](#regexp-func-runPartial)
  - [func runFullLongest(re, refull *Regexp, text string) ([]int, string)](#regexp-func-runFullLongest)
  - [func runPartialLongest(re, refull *Regexp, text string) ([]int, string)](#regexp-func-runPartialLongest)
  - [func matchFull(re, refull *Regexp, text string) (bool, string)](#regexp-func-matchFull)
  - [func matchPartial(re, refull *Regexp, text string) (bool, string)](#regexp-func-matchPartial)
  - [func matchFullLongest(re, refull *Regexp, text string) (bool, string)](#regexp-func-matchFullLongest)
  - [func matchPartialLongest(re, refull *Regexp, text string) (bool, string)](#regexp-func-matchPartialLongest)
  - [func isSingleBytes(s string) bool](#regexp-func-isSingleBytes)
  - [func parseResult(t *testing.T, file string, lineno int, res string) []int](#regexp-func-parseResult)
  - [func same(x, y []int) bool](#regexp-func-same)
  - [func TestFowler(t *testing.T)](#regexp-func-TestFowler)
  - [func testFowler(t *testing.T, file string)](#regexp-func-testFowler)
  - [func parseFowlerResult(s string) (ok, compiled, matched bool, pos []int)](#regexp-func-parseFowlerResult)
  - [func makeText(n int) []byte](#regexp-func-makeText)
  - [func BenchmarkMatch(b *testing.B)](#regexp-func-BenchmarkMatch)
  - [func BenchmarkMatch_onepass_regex(b *testing.B)](#regexp-func-BenchmarkMatch_onepass_regex)
  - [func TestLongest(t *testing.T)](#regexp-func-TestLongest)
  - [func TestProgramTooLongForBacktrack(t *testing.T)](#regexp-func-TestProgramTooLongForBacktrack)
  - [func build(n int, x ...int) [][]int](#regexp-func-build)
  - [func TestFind(t *testing.T)](#regexp-func-TestFind)
  - [func TestFindString(t *testing.T)](#regexp-func-TestFindString)
  - [func testFindIndex(test *FindTest, result []int, t *testing.T)](#regexp-func-testFindIndex)
  - [func TestFindIndex(t *testing.T)](#regexp-func-TestFindIndex)
  - [func TestFindStringIndex(t *testing.T)](#regexp-func-TestFindStringIndex)
  - [func TestFindReaderIndex(t *testing.T)](#regexp-func-TestFindReaderIndex)
  - [func TestFindAll(t *testing.T)](#regexp-func-TestFindAll)
  - [func TestFindAllString(t *testing.T)](#regexp-func-TestFindAllString)
  - [func testFindAllIndex(test *FindTest, result [][]int, t *testing.T)](#regexp-func-testFindAllIndex)
  - [func TestFindAllIndex(t *testing.T)](#regexp-func-TestFindAllIndex)
  - [func TestFindAllStringIndex(t *testing.T)](#regexp-func-TestFindAllStringIndex)
  - [func testSubmatchBytes(test *FindTest, n int, submatches []int, result [][]byte, t *testing.T)](#regexp-func-testSubmatchBytes)
  - [func TestFindSubmatch(t *testing.T)](#regexp-func-TestFindSubmatch)
  - [func testSubmatchString(test *FindTest, n int, submatches []int, result []string, t *testing.T)](#regexp-func-testSubmatchString)
  - [func TestFindStringSubmatch(t *testing.T)](#regexp-func-TestFindStringSubmatch)
  - [func testSubmatchIndices(test *FindTest, n int, expect, result []int, t *testing.T)](#regexp-func-testSubmatchIndices)
  - [func testFindSubmatchIndex(test *FindTest, result []int, t *testing.T)](#regexp-func-testFindSubmatchIndex)
  - [func TestFindSubmatchIndex(t *testing.T)](#regexp-func-TestFindSubmatchIndex)
  - [func TestFindStringSubmatchIndex(t *testing.T)](#regexp-func-TestFindStringSubmatchIndex)
  - [func TestFindReaderSubmatchIndex(t *testing.T)](#regexp-func-TestFindReaderSubmatchIndex)
  - [func TestFindAllSubmatch(t *testing.T)](#regexp-func-TestFindAllSubmatch)
  - [func TestFindAllStringSubmatch(t *testing.T)](#regexp-func-TestFindAllStringSubmatch)
  - [func testFindAllSubmatchIndex(test *FindTest, result [][]int, t *testing.T)](#regexp-func-testFindAllSubmatchIndex)
  - [func TestFindAllSubmatchIndex(t *testing.T)](#regexp-func-TestFindAllSubmatchIndex)
  - [func TestFindAllStringSubmatchIndex(t *testing.T)](#regexp-func-TestFindAllStringSubmatchIndex)
  - [func TestMergeRuneSet(t *testing.T)](#regexp-func-TestMergeRuneSet)
  - [func TestCompileOnePass(t *testing.T)](#regexp-func-TestCompileOnePass)
  - [func TestRunOnePass(t *testing.T)](#regexp-func-TestRunOnePass)

### <a name="regexp-const">Constants <small>(exported)</small></a>

#### <a name="regexp-const-visitedBits">const visitedBits</a>

```Go
const visitedBits = 32
```

#### <a name="regexp-const-maxBacktrackProg">const maxBacktrackProg</a>

```Go
const maxBacktrackProg = 500 // len(prog.Inst) <= max

```

#### <a name="regexp-const-maxBacktrackVector">const maxBacktrackVector</a>

```Go
const maxBacktrackVector = 256 * 1024 // bit vector size <= max (bits)

```

#### <a name="regexp-const-mergeFailed">const mergeFailed</a>

```Go
const mergeFailed = uint32(0xffffffff)
```

mergeRuneSets merges two non-intersecting runesets, and returns the merged result, and a NextIp array. The idea is that if a rune matches the OnePassRunes at index i, NextIp[i/2] is the target. If the input sets intersect, an empty runeset and a NextIp array with the single element mergeFailed is returned. The code assumes that both inputs contain ordered and non-intersecting rune pairs. 

#### <a name="regexp-const-endOfText">const endOfText</a>

```Go
const endOfText rune = -1
```

#### <a name="regexp-const-startSize">const startSize</a>

```Go
const startSize = 10 // The size at which to start a slice in the 'All' routines.

```

### <a name="regexp-var">Variables <small>(exported)</small></a>

#### <a name="regexp-var-bitStatePool">var bitStatePool</a>

```Go
var bitStatePool sync.Pool
```

#### <a name="regexp-var-t">var t</a>

```Go
var t *thread
```

#### <a name="regexp-var-flag">var flag</a>

```Go
var flag lazyFlag
```

#### <a name="regexp-var-onePassPool">var onePassPool</a>

```Go
var onePassPool sync.Pool
```

#### <a name="regexp-var-flag">var flag</a>

```Go
var flag lazyFlag
```

#### <a name="regexp-var-arrayNoInts">var arrayNoInts</a>

```Go
var arrayNoInts [0]int
```

arrayNoInts is returned by doExecute match if nil dstCap is passed to it with ncap=0. 

#### <a name="regexp-var-buf">var buf</a>

```Go
var buf strings.Builder
```

Have prefix; gather characters. 

#### <a name="regexp-var-noRune">var noRune</a>

```Go
var noRune = ...
```

#### <a name="regexp-var-noNext">var noNext</a>

```Go
var noNext = ...
```

#### <a name="regexp-var-lx">var lx</a>

```Go
var lx, rx int
```

#### <a name="regexp-var-rx">var rx</a>

```Go
var lx, rx int
```

#### <a name="regexp-var-anyRuneNotNL">var anyRuneNotNL</a>

```Go
var anyRuneNotNL = ...
```

#### <a name="regexp-var-anyRune">var anyRune</a>

```Go
var anyRune = ...
```

#### <a name="regexp-var-instQueue">var instQueue</a>

```Go
var instQueue = newQueue(len(p.Inst))
```

#### <a name="regexp-var-visitQueue">var visitQueue</a>

```Go
var visitQueue = newQueue(len(p.Inst))
```

#### <a name="regexp-var-check">var check</a>

```Go
var check func(uint32, []bool) bool
```

#### <a name="regexp-var-onePassRunes">var onePassRunes</a>

```Go
var onePassRunes = make([][]rune, len(p.Inst))
```

#### <a name="regexp-var-matchSize">var matchSize</a>

```Go
var matchSize = ...
```

Pools of *machine for use during (*Regexp).doExecute, split up by the size of the execution queues. matchPool[i] machines have queue size matchSize[i]. On a 64-bit system each queue entry is 16 bytes, so matchPool[0] has 16*2*128 = 4kB queues, etc. The final matchPool is a catch-all for very large queues. 

#### <a name="regexp-var-matchPool">var matchPool</a>

```Go
var matchPool [len(matchSize)]sync.Pool
```

Pools of *machine for use during (*Regexp).doExecute, split up by the size of the execution queues. matchPool[i] machines have queue size matchSize[i]. On a 64-bit system each queue entry is 16 bytes, so matchPool[0] has 16*2*128 = 4kB queues, etc. The final matchPool is a catch-all for very large queues. 

#### <a name="regexp-var-lnext">var lnext</a>

```Go
var lnext int
```

#### <a name="regexp-var-buf">var buf</a>

```Go
var buf []byte
```

#### <a name="regexp-var-endPos">var endPos</a>

```Go
var endPos int
```

#### <a name="regexp-var-dstCap">var dstCap</a>

```Go
var dstCap [2]int
```

#### <a name="regexp-var-width">var width</a>

```Go
var width int
```

Advance past this match; always advance at least one character. 

#### <a name="regexp-var-specialBytes">var specialBytes</a>

```Go
var specialBytes [16]byte
```

Bitmap used by func special to check whether a character needs to be escaped. 

#### <a name="regexp-var-i">var i</a>

```Go
var i int
```

A byte loop is correct because all metacharacters are ASCII. 

#### <a name="regexp-var-end">var end</a>

```Go
var end int
```

#### <a name="regexp-var-width">var width</a>

```Go
var width int
```

#### <a name="regexp-var-dstCap">var dstCap</a>

```Go
var dstCap [2]int
```

#### <a name="regexp-var-dstCap">var dstCap</a>

```Go
var dstCap [2]int
```

#### <a name="regexp-var-dstCap">var dstCap</a>

```Go
var dstCap [4]int
```

#### <a name="regexp-var-dstCap">var dstCap</a>

```Go
var dstCap [4]int
```

#### <a name="regexp-var-result">var result</a>

```Go
var result [][]byte
```

#### <a name="regexp-var-result">var result</a>

```Go
var result [][]int
```

#### <a name="regexp-var-result">var result</a>

```Go
var result []string
```

#### <a name="regexp-var-result">var result</a>

```Go
var result [][]int
```

#### <a name="regexp-var-result">var result</a>

```Go
var result [][][]byte
```

#### <a name="regexp-var-result">var result</a>

```Go
var result [][]int
```

#### <a name="regexp-var-result">var result</a>

```Go
var result [][]string
```

#### <a name="regexp-var-result">var result</a>

```Go
var result [][]int
```

#### <a name="regexp-var-goodRe">var goodRe</a>

```Go
var goodRe = ...
```

#### <a name="regexp-var-badRe">var badRe</a>

```Go
var badRe = ...
```

#### <a name="regexp-var-replaceTests">var replaceTests</a>

```Go
var replaceTests = ...
```

#### <a name="regexp-var-replaceLiteralTests">var replaceLiteralTests</a>

```Go
var replaceLiteralTests = ...
```

#### <a name="regexp-var-replaceFuncTests">var replaceFuncTests</a>

```Go
var replaceFuncTests = ...
```

#### <a name="regexp-var-metaTests">var metaTests</a>

```Go
var metaTests = ...
```

#### <a name="regexp-var-literalPrefixTests">var literalPrefixTests</a>

```Go
var literalPrefixTests = ...
```

#### <a name="regexp-var-emptySubexpIndices">var emptySubexpIndices</a>

```Go
var emptySubexpIndices = ...
```

#### <a name="regexp-var-subexpCases">var subexpCases</a>

```Go
var subexpCases = ...
```

#### <a name="regexp-var-splitTests">var splitTests</a>

```Go
var splitTests = ...
```

#### <a name="regexp-var-sink">var sink</a>

```Go
var sink string
```

#### <a name="regexp-var-compileBenchData">var compileBenchData</a>

```Go
var compileBenchData = ...
```

#### <a name="regexp-var-minInputLenTests">var minInputLenTests</a>

```Go
var minInputLenTests = ...
```

#### <a name="regexp-var-txt">var txt</a>

```Go
var txt io.Reader
```

#### <a name="regexp-var-str">var str</a>

```Go
var str []string
```

#### <a name="regexp-var-input">var input</a>

```Go
var input []string
```

#### <a name="regexp-var-inStrings">var inStrings</a>

```Go
var inStrings bool
```

#### <a name="regexp-var-re">var re</a>

```Go
var re *Regexp
```

#### <a name="regexp-var-refull">var refull</a>

```Go
var refull *Regexp
```

#### <a name="regexp-var-nfail">var nfail</a>

```Go
var nfail int
```

#### <a name="regexp-var-ncase">var ncase</a>

```Go
var ncase int
```

#### <a name="regexp-var-text">var text</a>

```Go
var text string
```

#### <a name="regexp-var-run">var run</a>

```Go
var run = ...
```

#### <a name="regexp-var-match">var match</a>

```Go
var match = ...
```

#### <a name="regexp-var-notab">var notab</a>

```Go
var notab = MustCompilePOSIX(`[^\t]+`)
```

#### <a name="regexp-var-x">var x</a>

```Go
var x []int
```

#### <a name="regexp-var-end">var end</a>

```Go
var end byte = ')'
```

#### <a name="regexp-var-v">var v</a>

```Go
var v = -1
```

#### <a name="regexp-var-err">var err</a>

```Go
var err error
```

#### <a name="regexp-var-text">var text</a>

```Go
var text []byte
```

#### <a name="regexp-var-benchData">var benchData</a>

```Go
var benchData = ...
```

#### <a name="regexp-var-benchSizes">var benchSizes</a>

```Go
var benchSizes = ...
```

#### <a name="regexp-var-findTests">var findTests</a>

```Go
var findTests = ...
```

#### <a name="regexp-var-runeMergeTests">var runeMergeTests</a>

```Go
var runeMergeTests = ...
```

#### <a name="regexp-var-onePassTests">var onePassTests</a>

```Go
var onePassTests = ...
```

#### <a name="regexp-var-p">var p</a>

```Go
var p *syntax.Prog
```

#### <a name="regexp-var-re">var re</a>

```Go
var re *syntax.Regexp
```

#### <a name="regexp-var-err">var err</a>

```Go
var err error
```

#### <a name="regexp-var-onePassTests1">var onePassTests1</a>

```Go
var onePassTests1 = ...
```

TODO(cespare): Unify with onePassTests and rationalize one-pass test cases. 

### <a name="regexp-type">Types <small>(exported)</small></a>

#### <a name="regexp-type-job">type job struct</a>

```Go
type job struct {
	pc  uint32
	arg bool
	pos int
}
```

A job is an entry on the backtracker's job stack. It holds the instruction pc and the position in the input. 

#### <a name="regexp-type-bitState">type bitState struct</a>

```Go
type bitState struct {
	end      int
	cap      []int
	matchcap []int
	jobs     []job
	visited  []uint32

	inputs inputs
}
```

bitState holds state for the backtracker. 

##### <a name="regexp-type-bitState-newBitState">func newBitState() *bitState</a>

```Go
func newBitState() *bitState
```

##### <a name="regexp-type-bitState-reset">func (b *bitState) reset(prog *syntax.Prog, end int, ncap int)</a>

```Go
func (b *bitState) reset(prog *syntax.Prog, end int, ncap int)
```

reset resets the state of the backtracker. end is the end position in the input. ncap is the number of captures. 

##### <a name="regexp-type-bitState-shouldVisit">func (b *bitState) shouldVisit(pc uint32, pos int) bool</a>

```Go
func (b *bitState) shouldVisit(pc uint32, pos int) bool
```

shouldVisit reports whether the combination of (pc, pos) has not been visited yet. 

##### <a name="regexp-type-bitState-push">func (b *bitState) push(re *Regexp, pc uint32, pos int, arg bool)</a>

```Go
func (b *bitState) push(re *Regexp, pc uint32, pos int, arg bool)
```

push pushes (pc, pos, arg) onto the job stack if it should be visited. 

#### <a name="regexp-type-queue">type queue struct</a>

```Go
type queue struct {
	sparse []uint32
	dense  []entry
}
```

A queue is a 'sparse array' holding pending threads of execution. See [https://research.swtch.com/2008/03/using-uninitialized-memory-for-fun-and.html](https://research.swtch.com/2008/03/using-uninitialized-memory-for-fun-and.html) 

#### <a name="regexp-type-entry">type entry struct</a>

```Go
type entry struct {
	pc uint32
	t  *thread
}
```

An entry is an entry on a queue. It holds both the instruction pc and the actual thread. Some queue entries are just place holders so that the machine knows it has considered that pc. Such entries have t == nil. 

#### <a name="regexp-type-thread">type thread struct</a>

```Go
type thread struct {
	inst *syntax.Inst
	cap  []int
}
```

A thread is the state of a single path through the machine: an instruction and a corresponding capture array. See [https://swtch.com/~rsc/regexp/regexp2.html](https://swtch.com/~rsc/regexp/regexp2.html) 

#### <a name="regexp-type-machine">type machine struct</a>

```Go
type machine struct {
	re       *Regexp      // corresponding Regexp
	p        *syntax.Prog // compiled program
	q0, q1   queue        // two queues for runq, nextq
	pool     []*thread    // pool of available threads
	matched  bool         // whether a match was found
	matchcap []int        // capture information for the match

	inputs inputs
}
```

A machine holds all the state during an NFA simulation for p. 

##### <a name="regexp-type-machine-init">func (m *machine) init(ncap int)</a>

```Go
func (m *machine) init(ncap int)
```

##### <a name="regexp-type-machine-alloc">func (m *machine) alloc(i *syntax.Inst) *thread</a>

```Go
func (m *machine) alloc(i *syntax.Inst) *thread
```

alloc allocates a new thread with the given instruction. It uses the free pool if possible. 

##### <a name="regexp-type-machine-match">func (m *machine) match(i input, pos int) bool</a>

```Go
func (m *machine) match(i input, pos int) bool
```

match runs the machine over the input starting at pos. It reports whether a match was found. If so, m.matchcap holds the submatch information. 

##### <a name="regexp-type-machine-clear">func (m *machine) clear(q *queue)</a>

```Go
func (m *machine) clear(q *queue)
```

clear frees all threads on the thread queue. 

##### <a name="regexp-type-machine-step">func (m *machine) step(runq, nextq *queue, pos, nextPos int, c rune, nextCond *lazyFlag)</a>

```Go
func (m *machine) step(runq, nextq *queue, pos, nextPos int, c rune, nextCond *lazyFlag)
```

step executes one step of the machine, running each of the threads on runq and appending new threads to nextq. The step processes the rune c (which may be endOfText), which starts at position pos and ends at nextPos. nextCond gives the setting for the empty-width flags after c. 

##### <a name="regexp-type-machine-add">func (m *machine) add(q *queue, pc uint32, pos int, cap []int, cond *lazyFlag, t *thread) *thread</a>

```Go
func (m *machine) add(q *queue, pc uint32, pos int, cap []int, cond *lazyFlag, t *thread) *thread
```

add adds an entry to q for pc, unless the q already has such an entry. It also recursively adds an entry for all instructions reachable from pc by following empty-width conditions satisfied by cond.  pos gives the current position in the input. 

#### <a name="regexp-type-inputs">type inputs struct</a>

```Go
type inputs struct {
	// cached inputs, to avoid allocation
	bytes  inputBytes
	string inputString
	reader inputReader
}
```

##### <a name="regexp-type-inputs-newBytes">func (i *inputs) newBytes(b []byte) input</a>

```Go
func (i *inputs) newBytes(b []byte) input
```

##### <a name="regexp-type-inputs-newString">func (i *inputs) newString(s string) input</a>

```Go
func (i *inputs) newString(s string) input
```

##### <a name="regexp-type-inputs-newReader">func (i *inputs) newReader(r io.RuneReader) input</a>

```Go
func (i *inputs) newReader(r io.RuneReader) input
```

##### <a name="regexp-type-inputs-clear">func (i *inputs) clear()</a>

```Go
func (i *inputs) clear()
```

##### <a name="regexp-type-inputs-init">func (i *inputs) init(r io.RuneReader, b []byte, s string) (input, int)</a>

```Go
func (i *inputs) init(r io.RuneReader, b []byte, s string) (input, int)
```

#### <a name="regexp-type-lazyFlag">type lazyFlag uint64</a>

```Go
type lazyFlag uint64
```

A lazyFlag is a lazily-evaluated syntax.EmptyOp, for checking zero-width flags like ^ $ \A \z \B \b. It records the pair of relevant runes and does not determine the implied flags until absolutely necessary (most of the time, that means never). 

##### <a name="regexp-type-lazyFlag-newLazyFlag">func newLazyFlag(r1, r2 rune) lazyFlag</a>

```Go
func newLazyFlag(r1, r2 rune) lazyFlag
```

##### <a name="regexp-type-lazyFlag-match">func (f lazyFlag) match(op syntax.EmptyOp) bool</a>

```Go
func (f lazyFlag) match(op syntax.EmptyOp) bool
```

#### <a name="regexp-type-onePassMachine">type onePassMachine struct</a>

```Go
type onePassMachine struct {
	inputs   inputs
	matchcap []int
}
```

##### <a name="regexp-type-onePassMachine-newOnePassMachine">func newOnePassMachine() *onePassMachine</a>

```Go
func newOnePassMachine() *onePassMachine
```

#### <a name="regexp-type-onePassProg">type onePassProg struct</a>

```Go
type onePassProg struct {
	Inst   []onePassInst
	Start  int // index of start instruction
	NumCap int // number of InstCapture insts in re
}
```

A onePassProg is a compiled one-pass regular expression program. It is the same as syntax.Prog except for the use of onePassInst. 

##### <a name="regexp-type-onePassProg-onePassCopy">func onePassCopy(prog *syntax.Prog) *onePassProg</a>

```Go
func onePassCopy(prog *syntax.Prog) *onePassProg
```

onePassCopy creates a copy of the original Prog, as we'll be modifying it 

##### <a name="regexp-type-onePassProg-makeOnePass">func makeOnePass(p *onePassProg) *onePassProg</a>

```Go
func makeOnePass(p *onePassProg) *onePassProg
```

makeOnePass creates a onepass Prog, if possible. It is possible if at any alt, the match engine can always tell which branch to take. The routine may modify p if it is turned into a onepass Prog. If it isn't possible for this to be a onepass Prog, the Prog nil is returned. makeOnePass is recursive to the size of the Prog. 

##### <a name="regexp-type-onePassProg-compileOnePass">func compileOnePass(prog *syntax.Prog) (p *onePassProg)</a>

```Go
func compileOnePass(prog *syntax.Prog) (p *onePassProg)
```

compileOnePass returns a new *syntax.Prog suitable for onePass execution if the original Prog can be recharacterized as a one-pass regexp program, or syntax.nil if the Prog cannot be converted. For a one pass prog, the fundamental condition that must be true is: at any InstAlt, there must be no ambiguity about what branch to  take. 

#### <a name="regexp-type-onePassInst">type onePassInst struct</a>

```Go
type onePassInst struct {
	syntax.Inst
	Next []uint32
}
```

A onePassInst is a single instruction in a one-pass regular expression program. It is the same as syntax.Inst except for the new 'Next' field. 

#### <a name="regexp-type-queueOnePass">type queueOnePass struct</a>

```Go
type queueOnePass struct {
	sparse          []uint32
	dense           []uint32
	size, nextIndex uint32
}
```

Sparse Array implementation is used as a queueOnePass. 

##### <a name="regexp-type-queueOnePass-newQueue">func newQueue(size int) (q *queueOnePass)</a>

```Go
func newQueue(size int) (q *queueOnePass)
```

##### <a name="regexp-type-queueOnePass-empty">func (q *queueOnePass) empty() bool</a>

```Go
func (q *queueOnePass) empty() bool
```

##### <a name="regexp-type-queueOnePass-next">func (q *queueOnePass) next() (n uint32)</a>

```Go
func (q *queueOnePass) next() (n uint32)
```

##### <a name="regexp-type-queueOnePass-clear">func (q *queueOnePass) clear()</a>

```Go
func (q *queueOnePass) clear()
```

##### <a name="regexp-type-queueOnePass-contains">func (q *queueOnePass) contains(u uint32) bool</a>

```Go
func (q *queueOnePass) contains(u uint32) bool
```

##### <a name="regexp-type-queueOnePass-insert">func (q *queueOnePass) insert(u uint32)</a>

```Go
func (q *queueOnePass) insert(u uint32)
```

##### <a name="regexp-type-queueOnePass-insertNew">func (q *queueOnePass) insertNew(u uint32)</a>

```Go
func (q *queueOnePass) insertNew(u uint32)
```

#### <a name="regexp-type-runeSlice">type runeSlice []rune</a>

```Go
type runeSlice []rune
```

runeSlice exists to permit sorting the case-folded rune sets. 

##### <a name="regexp-type-runeSlice-Len">func (p runeSlice) Len() int</a>

```Go
func (p runeSlice) Len() int
```

##### <a name="regexp-type-runeSlice-Less">func (p runeSlice) Less(i, j int) bool</a>

```Go
func (p runeSlice) Less(i, j int) bool
```

##### <a name="regexp-type-runeSlice-Swap">func (p runeSlice) Swap(i, j int)</a>

```Go
func (p runeSlice) Swap(i, j int)
```

#### <a name="regexp-type-Regexp">type Regexp struct <small>(exported)</small></a>

```Go
type Regexp struct {
	expr           string       // as passed to Compile
	prog           *syntax.Prog // compiled program
	onepass        *onePassProg // onepass program or nil
	numSubexp      int
	maxBitStateLen int
	subexpNames    []string
	prefix         string         // required prefix in unanchored matches
	prefixBytes    []byte         // prefix, as a []byte
	prefixRune     rune           // first rune in prefix
	prefixEnd      uint32         // pc for last rune in prefix
	mpool          int            // pool for machines
	matchcap       int            // size of recorded match lengths
	prefixComplete bool           // prefix is the entire regexp
	cond           syntax.EmptyOp // empty-width conditions required at start of match
	minInputLen    int            // minimum length of the input in bytes

	// This field can be modified by the Longest method,
	// but it is otherwise read-only.
	longest bool // whether regexp prefers leftmost-longest match
}
```

Regexp is the representation of a compiled regular expression. A Regexp is safe for concurrent use by multiple goroutines, except for configuration methods, such as Longest. 

##### <a name="regexp-type-Regexp-Compile">func Compile(expr string) (*Regexp, error) <small>(exported)</small></a>

```Go
func Compile(expr string) (*Regexp, error)
```

Compile parses a regular expression and returns, if successful, a Regexp object that can be used to match against text. 

When matching against text, the regexp returns a match that begins as early as possible in the input (leftmost), and among those it chooses the one that a backtracking search would have found first. This so-called leftmost-first matching is the same semantics that Perl, Python, and other implementations use, although this package implements it without the expense of backtracking. For POSIX leftmost-longest matching, see CompilePOSIX. 

##### <a name="regexp-type-Regexp-CompilePOSIX">func CompilePOSIX(expr string) (*Regexp, error) <small>(exported)</small></a>

```Go
func CompilePOSIX(expr string) (*Regexp, error)
```

CompilePOSIX is like Compile but restricts the regular expression to POSIX ERE (egrep) syntax and changes the match semantics to leftmost-longest. 

That is, when matching against text, the regexp returns a match that begins as early as possible in the input (leftmost), and among those it chooses a match that is as long as possible. This so-called leftmost-longest matching is the same semantics that early regular expression implementations used and that POSIX specifies. 

However, there can be multiple leftmost-longest matches, with different submatch choices, and here this package diverges from POSIX. Among the possible leftmost-longest matches, this package chooses the one that a backtracking search would have found first, while POSIX specifies that the match be chosen to maximize the length of the first subexpression, then the second, and so on from left to right. The POSIX rule is computationally prohibitive and not even well-defined. See [https://swtch.com/~rsc/regexp/regexp2.html#posix](https://swtch.com/~rsc/regexp/regexp2.html#posix) for details. 

##### <a name="regexp-type-Regexp-compile">func compile(expr string, mode syntax.Flags, longest bool) (*Regexp, error)</a>

```Go
func compile(expr string, mode syntax.Flags, longest bool) (*Regexp, error)
```

##### <a name="regexp-type-Regexp-MustCompile">func MustCompile(str string) *Regexp <small>(exported)</small></a>

```Go
func MustCompile(str string) *Regexp
```

MustCompile is like Compile but panics if the expression cannot be parsed. It simplifies safe initialization of global variables holding compiled regular expressions. 

##### <a name="regexp-type-Regexp-MustCompilePOSIX">func MustCompilePOSIX(str string) *Regexp <small>(exported)</small></a>

```Go
func MustCompilePOSIX(str string) *Regexp
```

MustCompilePOSIX is like CompilePOSIX but panics if the expression cannot be parsed. It simplifies safe initialization of global variables holding compiled regular expressions. 

##### <a name="regexp-type-Regexp-compileTest">func compileTest(t *testing.T, expr string, error string) *Regexp</a>

```Go
func compileTest(t *testing.T, expr string, error string) *Regexp
```

##### <a name="regexp-type-Regexp-tryCompile">func tryCompile(s string) (re *Regexp, err error)</a>

```Go
func tryCompile(s string) (re *Regexp, err error)
```

##### <a name="regexp-type-Regexp-tryBacktrack">func (re *Regexp) tryBacktrack(b *bitState, i input, pc uint32, pos int) bool</a>

```Go
func (re *Regexp) tryBacktrack(b *bitState, i input, pc uint32, pos int) bool
```

tryBacktrack runs a backtracking search starting at pos. 

##### <a name="regexp-type-Regexp-backtrack">func (re *Regexp) backtrack(ib []byte, is string, pos int, ncap int, dstCap []int) []int</a>

```Go
func (re *Regexp) backtrack(ib []byte, is string, pos int, ncap int, dstCap []int) []int
```

backtrack runs a backtracking search of prog on the input starting at pos. 

##### <a name="regexp-type-Regexp-doOnePass">func (re *Regexp) doOnePass(ir io.RuneReader, ib []byte, is string, pos, ncap int, dstCap []int) []int</a>

```Go
func (re *Regexp) doOnePass(ir io.RuneReader, ib []byte, is string, pos, ncap int, dstCap []int) []int
```

doOnePass implements r.doExecute using the one-pass execution engine. 

##### <a name="regexp-type-Regexp-doMatch">func (re *Regexp) doMatch(r io.RuneReader, b []byte, s string) bool</a>

```Go
func (re *Regexp) doMatch(r io.RuneReader, b []byte, s string) bool
```

doMatch reports whether either r, b or s match the regexp. 

##### <a name="regexp-type-Regexp-doExecute">func (re *Regexp) doExecute(r io.RuneReader, b []byte, s string, pos int, ncap int, dstCap []int) []int</a>

```Go
func (re *Regexp) doExecute(r io.RuneReader, b []byte, s string, pos int, ncap int, dstCap []int) []int
```

doExecute finds the leftmost match in the input, appends the position of its subexpressions to dstCap and returns dstCap. 

nil is returned if no matches are found and non-nil if matches are found. 

##### <a name="regexp-type-Regexp-String">func (re *Regexp) String() string <small>(exported)</small></a>

```Go
func (re *Regexp) String() string
```

String returns the source text used to compile the regular expression. 

##### <a name="regexp-type-Regexp-Copy">func (re *Regexp) Copy() *Regexp <small>(exported,deprecated)</small></a>

```Go
func (re *Regexp) Copy() *Regexp
```

Copy returns a new Regexp object copied from re. Calling Longest on one copy does not affect another. 

Deprecated: In earlier releases, when using a Regexp in multiple goroutines, giving each goroutine its own copy helped to avoid lock contention. As of Go 1.12, using Copy is no longer necessary to avoid lock contention. Copy may still be appropriate if the reason for its use is to make two copies with different Longest settings. 

##### <a name="regexp-type-Regexp-Longest">func (re *Regexp) Longest() <small>(exported)</small></a>

```Go
func (re *Regexp) Longest()
```

Longest makes future searches prefer the leftmost-longest match. That is, when matching against text, the regexp returns a match that begins as early as possible in the input (leftmost), and among those it chooses a match that is as long as possible. This method modifies the Regexp and may not be called concurrently with any other methods. 

##### <a name="regexp-type-Regexp-get">func (re *Regexp) get() *machine</a>

```Go
func (re *Regexp) get() *machine
```

get returns a machine to use for matching re. It uses the re's machine cache if possible, to avoid unnecessary allocation. 

##### <a name="regexp-type-Regexp-put">func (re *Regexp) put(m *machine)</a>

```Go
func (re *Regexp) put(m *machine)
```

put returns a machine to the correct machine pool. 

##### <a name="regexp-type-Regexp-NumSubexp">func (re *Regexp) NumSubexp() int <small>(exported)</small></a>

```Go
func (re *Regexp) NumSubexp() int
```

NumSubexp returns the number of parenthesized subexpressions in this Regexp. 

##### <a name="regexp-type-Regexp-SubexpNames">func (re *Regexp) SubexpNames() []string <small>(exported)</small></a>

```Go
func (re *Regexp) SubexpNames() []string
```

SubexpNames returns the names of the parenthesized subexpressions in this Regexp. The name for the first sub-expression is names[1], so that if m is a match slice, the name for m[i] is SubexpNames()[i]. Since the Regexp as a whole cannot be named, names[0] is always the empty string. The slice should not be modified. 

##### <a name="regexp-type-Regexp-SubexpIndex">func (re *Regexp) SubexpIndex(name string) int <small>(exported)</small></a>

```Go
func (re *Regexp) SubexpIndex(name string) int
```

SubexpIndex returns the index of the first subexpression with the given name, or -1 if there is no subexpression with that name. 

Note that multiple subexpressions can be written using the same name, as in (?P<bob>a+)(?P<bob>b+), which declares two subexpressions named "bob". In this case, SubexpIndex returns the index of the leftmost such subexpression in the regular expression. 

##### <a name="regexp-type-Regexp-LiteralPrefix">func (re *Regexp) LiteralPrefix() (prefix string, complete bool) <small>(exported)</small></a>

```Go
func (re *Regexp) LiteralPrefix() (prefix string, complete bool)
```

LiteralPrefix returns a literal string that must begin any match of the regular expression re. It returns the boolean true if the literal string comprises the entire regular expression. 

##### <a name="regexp-type-Regexp-MatchReader">func (re *Regexp) MatchReader(r io.RuneReader) bool <small>(exported)</small></a>

```Go
func (re *Regexp) MatchReader(r io.RuneReader) bool
```

MatchReader reports whether the text returned by the RuneReader contains any match of the regular expression re. 

##### <a name="regexp-type-Regexp-MatchString">func (re *Regexp) MatchString(s string) bool <small>(exported)</small></a>

```Go
func (re *Regexp) MatchString(s string) bool
```

MatchString reports whether the string s contains any match of the regular expression re. 

##### <a name="regexp-type-Regexp-Match">func (re *Regexp) Match(b []byte) bool <small>(exported)</small></a>

```Go
func (re *Regexp) Match(b []byte) bool
```

Match reports whether the byte slice b contains any match of the regular expression re. 

##### <a name="regexp-type-Regexp-ReplaceAllString">func (re *Regexp) ReplaceAllString(src, repl string) string <small>(exported)</small></a>

```Go
func (re *Regexp) ReplaceAllString(src, repl string) string
```

ReplaceAllString returns a copy of src, replacing matches of the Regexp with the replacement string repl. Inside repl, $ signs are interpreted as in Expand, so for instance $1 represents the text of the first submatch. 

##### <a name="regexp-type-Regexp-ReplaceAllLiteralString">func (re *Regexp) ReplaceAllLiteralString(src, repl string) string <small>(exported)</small></a>

```Go
func (re *Regexp) ReplaceAllLiteralString(src, repl string) string
```

ReplaceAllLiteralString returns a copy of src, replacing matches of the Regexp with the replacement string repl. The replacement repl is substituted directly, without using Expand. 

##### <a name="regexp-type-Regexp-ReplaceAllStringFunc">func (re *Regexp) ReplaceAllStringFunc(src string, repl func(string) string) string <small>(exported)</small></a>

```Go
func (re *Regexp) ReplaceAllStringFunc(src string, repl func(string) string) string
```

ReplaceAllStringFunc returns a copy of src in which all matches of the Regexp have been replaced by the return value of function repl applied to the matched substring. The replacement returned by repl is substituted directly, without using Expand. 

##### <a name="regexp-type-Regexp-replaceAll">func (re *Regexp) replaceAll(bsrc []byte, src string, nmatch int, repl func(dst []byte, m []int) []byte) []byte</a>

```Go
func (re *Regexp) replaceAll(bsrc []byte, src string, nmatch int, repl func(dst []byte, m []int) []byte) []byte
```

##### <a name="regexp-type-Regexp-ReplaceAll">func (re *Regexp) ReplaceAll(src, repl []byte) []byte <small>(exported)</small></a>

```Go
func (re *Regexp) ReplaceAll(src, repl []byte) []byte
```

ReplaceAll returns a copy of src, replacing matches of the Regexp with the replacement text repl. Inside repl, $ signs are interpreted as in Expand, so for instance $1 represents the text of the first submatch. 

##### <a name="regexp-type-Regexp-ReplaceAllLiteral">func (re *Regexp) ReplaceAllLiteral(src, repl []byte) []byte <small>(exported)</small></a>

```Go
func (re *Regexp) ReplaceAllLiteral(src, repl []byte) []byte
```

ReplaceAllLiteral returns a copy of src, replacing matches of the Regexp with the replacement bytes repl. The replacement repl is substituted directly, without using Expand. 

##### <a name="regexp-type-Regexp-ReplaceAllFunc">func (re *Regexp) ReplaceAllFunc(src []byte, repl func([]byte) []byte) []byte <small>(exported)</small></a>

```Go
func (re *Regexp) ReplaceAllFunc(src []byte, repl func([]byte) []byte) []byte
```

ReplaceAllFunc returns a copy of src in which all matches of the Regexp have been replaced by the return value of function repl applied to the matched byte slice. The replacement returned by repl is substituted directly, without using Expand. 

##### <a name="regexp-type-Regexp-pad">func (re *Regexp) pad(a []int) []int</a>

```Go
func (re *Regexp) pad(a []int) []int
```

The number of capture values in the program may correspond to fewer capturing expressions than are in the regexp. For example, "(a){0}" turns into an empty program, so the maximum capture in the program is 0 but we need to return an expression for \1.  Pad appends -1s to the slice a as needed. 

##### <a name="regexp-type-Regexp-allMatches">func (re *Regexp) allMatches(s string, b []byte, n int, deliver func([]int))</a>

```Go
func (re *Regexp) allMatches(s string, b []byte, n int, deliver func([]int))
```

allMatches calls deliver at most n times with the location of successive matches in the input text. The input text is b if non-nil, otherwise s. 

##### <a name="regexp-type-Regexp-Find">func (re *Regexp) Find(b []byte) []byte <small>(exported)</small></a>

```Go
func (re *Regexp) Find(b []byte) []byte
```

Find returns a slice holding the text of the leftmost match in b of the regular expression. A return value of nil indicates no match. 

##### <a name="regexp-type-Regexp-FindIndex">func (re *Regexp) FindIndex(b []byte) (loc []int) <small>(exported)</small></a>

```Go
func (re *Regexp) FindIndex(b []byte) (loc []int)
```

FindIndex returns a two-element slice of integers defining the location of the leftmost match in b of the regular expression. The match itself is at b[loc[0]:loc[1]]. A return value of nil indicates no match. 

##### <a name="regexp-type-Regexp-FindString">func (re *Regexp) FindString(s string) string <small>(exported)</small></a>

```Go
func (re *Regexp) FindString(s string) string
```

FindString returns a string holding the text of the leftmost match in s of the regular expression. If there is no match, the return value is an empty string, but it will also be empty if the regular expression successfully matches an empty string. Use FindStringIndex or FindStringSubmatch if it is necessary to distinguish these cases. 

##### <a name="regexp-type-Regexp-FindStringIndex">func (re *Regexp) FindStringIndex(s string) (loc []int) <small>(exported)</small></a>

```Go
func (re *Regexp) FindStringIndex(s string) (loc []int)
```

FindStringIndex returns a two-element slice of integers defining the location of the leftmost match in s of the regular expression. The match itself is at s[loc[0]:loc[1]]. A return value of nil indicates no match. 

##### <a name="regexp-type-Regexp-FindReaderIndex">func (re *Regexp) FindReaderIndex(r io.RuneReader) (loc []int) <small>(exported)</small></a>

```Go
func (re *Regexp) FindReaderIndex(r io.RuneReader) (loc []int)
```

FindReaderIndex returns a two-element slice of integers defining the location of the leftmost match of the regular expression in text read from the RuneReader. The match text was found in the input stream at byte offset loc[0] through loc[1]-1. A return value of nil indicates no match. 

##### <a name="regexp-type-Regexp-FindSubmatch">func (re *Regexp) FindSubmatch(b []byte) [][]byte <small>(exported)</small></a>

```Go
func (re *Regexp) FindSubmatch(b []byte) [][]byte
```

FindSubmatch returns a slice of slices holding the text of the leftmost match of the regular expression in b and the matches, if any, of its subexpressions, as defined by the 'Submatch' descriptions in the package comment. A return value of nil indicates no match. 

##### <a name="regexp-type-Regexp-Expand">func (re *Regexp) Expand(dst []byte, template []byte, src []byte, match []int) []byte <small>(exported)</small></a>

```Go
func (re *Regexp) Expand(dst []byte, template []byte, src []byte, match []int) []byte
```

Expand appends template to dst and returns the result; during the append, Expand replaces variables in the template with corresponding matches drawn from src. The match slice should have been returned by FindSubmatchIndex. 

In the template, a variable is denoted by a substring of the form $name or ${name}, where name is a non-empty sequence of letters, digits, and underscores. A purely numeric name like $1 refers to the submatch with the corresponding index; other names refer to capturing parentheses named with the (?P<name>...) syntax. A reference to an out of range or unmatched index or a name that is not present in the regular expression is replaced with an empty slice. 

In the $name form, name is taken to be as long as possible: $1x is equivalent to ${1x}, not ${1}x, and, $10 is equivalent to ${10}, not ${1}0. 

To insert a literal $ in the output, use $$ in the template. 

##### <a name="regexp-type-Regexp-ExpandString">func (re *Regexp) ExpandString(dst []byte, template string, src string, match []int) []byte <small>(exported)</small></a>

```Go
func (re *Regexp) ExpandString(dst []byte, template string, src string, match []int) []byte
```

ExpandString is like Expand but the template and source are strings. It appends to and returns a byte slice in order to give the calling code control over allocation. 

##### <a name="regexp-type-Regexp-expand">func (re *Regexp) expand(dst []byte, template string, bsrc []byte, src string, match []int) []byte</a>

```Go
func (re *Regexp) expand(dst []byte, template string, bsrc []byte, src string, match []int) []byte
```

##### <a name="regexp-type-Regexp-FindSubmatchIndex">func (re *Regexp) FindSubmatchIndex(b []byte) []int <small>(exported)</small></a>

```Go
func (re *Regexp) FindSubmatchIndex(b []byte) []int
```

FindSubmatchIndex returns a slice holding the index pairs identifying the leftmost match of the regular expression in b and the matches, if any, of its subexpressions, as defined by the 'Submatch' and 'Index' descriptions in the package comment. A return value of nil indicates no match. 

##### <a name="regexp-type-Regexp-FindStringSubmatch">func (re *Regexp) FindStringSubmatch(s string) []string <small>(exported)</small></a>

```Go
func (re *Regexp) FindStringSubmatch(s string) []string
```

FindStringSubmatch returns a slice of strings holding the text of the leftmost match of the regular expression in s and the matches, if any, of its subexpressions, as defined by the 'Submatch' description in the package comment. A return value of nil indicates no match. 

##### <a name="regexp-type-Regexp-FindStringSubmatchIndex">func (re *Regexp) FindStringSubmatchIndex(s string) []int <small>(exported)</small></a>

```Go
func (re *Regexp) FindStringSubmatchIndex(s string) []int
```

FindStringSubmatchIndex returns a slice holding the index pairs identifying the leftmost match of the regular expression in s and the matches, if any, of its subexpressions, as defined by the 'Submatch' and 'Index' descriptions in the package comment. A return value of nil indicates no match. 

##### <a name="regexp-type-Regexp-FindReaderSubmatchIndex">func (re *Regexp) FindReaderSubmatchIndex(r io.RuneReader) []int <small>(exported)</small></a>

```Go
func (re *Regexp) FindReaderSubmatchIndex(r io.RuneReader) []int
```

FindReaderSubmatchIndex returns a slice holding the index pairs identifying the leftmost match of the regular expression of text read by the RuneReader, and the matches, if any, of its subexpressions, as defined by the 'Submatch' and 'Index' descriptions in the package comment. A return value of nil indicates no match. 

##### <a name="regexp-type-Regexp-FindAll">func (re *Regexp) FindAll(b []byte, n int) [][]byte <small>(exported)</small></a>

```Go
func (re *Regexp) FindAll(b []byte, n int) [][]byte
```

FindAll is the 'All' version of Find; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match. 

##### <a name="regexp-type-Regexp-FindAllIndex">func (re *Regexp) FindAllIndex(b []byte, n int) [][]int <small>(exported)</small></a>

```Go
func (re *Regexp) FindAllIndex(b []byte, n int) [][]int
```

FindAllIndex is the 'All' version of FindIndex; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match. 

##### <a name="regexp-type-Regexp-FindAllString">func (re *Regexp) FindAllString(s string, n int) []string <small>(exported)</small></a>

```Go
func (re *Regexp) FindAllString(s string, n int) []string
```

FindAllString is the 'All' version of FindString; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match. 

##### <a name="regexp-type-Regexp-FindAllStringIndex">func (re *Regexp) FindAllStringIndex(s string, n int) [][]int <small>(exported)</small></a>

```Go
func (re *Regexp) FindAllStringIndex(s string, n int) [][]int
```

FindAllStringIndex is the 'All' version of FindStringIndex; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match. 

##### <a name="regexp-type-Regexp-FindAllSubmatch">func (re *Regexp) FindAllSubmatch(b []byte, n int) [][][]byte <small>(exported)</small></a>

```Go
func (re *Regexp) FindAllSubmatch(b []byte, n int) [][][]byte
```

FindAllSubmatch is the 'All' version of FindSubmatch; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match. 

##### <a name="regexp-type-Regexp-FindAllSubmatchIndex">func (re *Regexp) FindAllSubmatchIndex(b []byte, n int) [][]int <small>(exported)</small></a>

```Go
func (re *Regexp) FindAllSubmatchIndex(b []byte, n int) [][]int
```

FindAllSubmatchIndex is the 'All' version of FindSubmatchIndex; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match. 

##### <a name="regexp-type-Regexp-FindAllStringSubmatch">func (re *Regexp) FindAllStringSubmatch(s string, n int) [][]string <small>(exported)</small></a>

```Go
func (re *Regexp) FindAllStringSubmatch(s string, n int) [][]string
```

FindAllStringSubmatch is the 'All' version of FindStringSubmatch; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match. 

##### <a name="regexp-type-Regexp-FindAllStringSubmatchIndex">func (re *Regexp) FindAllStringSubmatchIndex(s string, n int) [][]int <small>(exported)</small></a>

```Go
func (re *Regexp) FindAllStringSubmatchIndex(s string, n int) [][]int
```

FindAllStringSubmatchIndex is the 'All' version of FindStringSubmatchIndex; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match. 

##### <a name="regexp-type-Regexp-Split">func (re *Regexp) Split(s string, n int) []string <small>(exported)</small></a>

```Go
func (re *Regexp) Split(s string, n int) []string
```

Split slices s into substrings separated by the expression and returns a slice of the substrings between those expression matches. 

The slice returned by this method consists of all the substrings of s not contained in the slice returned by FindAllString. When called on an expression that contains no metacharacters, it is equivalent to strings.SplitN. 

Example: 

```
s := regexp.MustCompile("a*").Split("abaabaccadaaae", 5)
// s: ["", "b", "b", "c", "cadaaae"]

```
The count determines the number of substrings to return: 

```
n > 0: at most n substrings; the last substring will be the unsplit remainder.
n == 0: the result is nil (zero substrings)
n < 0: all substrings

```
#### <a name="regexp-type-input">type input interface</a>

```Go
type input interface {
	step(pos int) (r rune, width int) // advance one rune
	canCheckPrefix() bool             // can we look ahead without losing info?
	hasPrefix(re *Regexp) bool
	index(re *Regexp, pos int) int
	context(pos int) lazyFlag
}
```

input abstracts different representations of the input text. It provides one-character lookahead. 

#### <a name="regexp-type-inputString">type inputString struct</a>

```Go
type inputString struct {
	str string
}
```

inputString scans a string. 

##### <a name="regexp-type-inputString-step">func (i *inputString) step(pos int) (rune, int)</a>

```Go
func (i *inputString) step(pos int) (rune, int)
```

##### <a name="regexp-type-inputString-canCheckPrefix">func (i *inputString) canCheckPrefix() bool</a>

```Go
func (i *inputString) canCheckPrefix() bool
```

##### <a name="regexp-type-inputString-hasPrefix">func (i *inputString) hasPrefix(re *Regexp) bool</a>

```Go
func (i *inputString) hasPrefix(re *Regexp) bool
```

##### <a name="regexp-type-inputString-index">func (i *inputString) index(re *Regexp, pos int) int</a>

```Go
func (i *inputString) index(re *Regexp, pos int) int
```

##### <a name="regexp-type-inputString-context">func (i *inputString) context(pos int) lazyFlag</a>

```Go
func (i *inputString) context(pos int) lazyFlag
```

#### <a name="regexp-type-inputBytes">type inputBytes struct</a>

```Go
type inputBytes struct {
	str []byte
}
```

inputBytes scans a byte slice. 

##### <a name="regexp-type-inputBytes-step">func (i *inputBytes) step(pos int) (rune, int)</a>

```Go
func (i *inputBytes) step(pos int) (rune, int)
```

##### <a name="regexp-type-inputBytes-canCheckPrefix">func (i *inputBytes) canCheckPrefix() bool</a>

```Go
func (i *inputBytes) canCheckPrefix() bool
```

##### <a name="regexp-type-inputBytes-hasPrefix">func (i *inputBytes) hasPrefix(re *Regexp) bool</a>

```Go
func (i *inputBytes) hasPrefix(re *Regexp) bool
```

##### <a name="regexp-type-inputBytes-index">func (i *inputBytes) index(re *Regexp, pos int) int</a>

```Go
func (i *inputBytes) index(re *Regexp, pos int) int
```

##### <a name="regexp-type-inputBytes-context">func (i *inputBytes) context(pos int) lazyFlag</a>

```Go
func (i *inputBytes) context(pos int) lazyFlag
```

#### <a name="regexp-type-inputReader">type inputReader struct</a>

```Go
type inputReader struct {
	r     io.RuneReader
	atEOT bool
	pos   int
}
```

inputReader scans a RuneReader. 

##### <a name="regexp-type-inputReader-step">func (i *inputReader) step(pos int) (rune, int)</a>

```Go
func (i *inputReader) step(pos int) (rune, int)
```

##### <a name="regexp-type-inputReader-canCheckPrefix">func (i *inputReader) canCheckPrefix() bool</a>

```Go
func (i *inputReader) canCheckPrefix() bool
```

##### <a name="regexp-type-inputReader-hasPrefix">func (i *inputReader) hasPrefix(re *Regexp) bool</a>

```Go
func (i *inputReader) hasPrefix(re *Regexp) bool
```

##### <a name="regexp-type-inputReader-index">func (i *inputReader) index(re *Regexp, pos int) int</a>

```Go
func (i *inputReader) index(re *Regexp, pos int) int
```

##### <a name="regexp-type-inputReader-context">func (i *inputReader) context(pos int) lazyFlag</a>

```Go
func (i *inputReader) context(pos int) lazyFlag
```

#### <a name="regexp-type-stringError">type stringError struct</a>

```Go
type stringError struct {
	re  string
	err string
}
```

#### <a name="regexp-type-ReplaceTest">type ReplaceTest struct</a>

```Go
type ReplaceTest struct {
	pattern, replacement, input, output string
}
```

#### <a name="regexp-type-ReplaceFuncTest">type ReplaceFuncTest struct</a>

```Go
type ReplaceFuncTest struct {
	pattern       string
	replacement   func(string) string
	input, output string
}
```

#### <a name="regexp-type-MetaTest">type MetaTest struct</a>

```Go
type MetaTest struct {
	pattern, output, literal string
	isLiteral                bool
}
```

#### <a name="regexp-type-subexpIndex">type subexpIndex struct</a>

```Go
type subexpIndex struct {
	name  string
	index int
}
```

#### <a name="regexp-type-subexpCase">type subexpCase struct</a>

```Go
type subexpCase struct {
	input   string
	num     int
	names   []string
	indices []subexpIndex
}
```

#### <a name="regexp-type-FindTest">type FindTest struct</a>

```Go
type FindTest struct {
	pat     string
	text    string
	matches [][]int
}
```

For each pattern/text pair, what is the expected output of each function? We can derive the textual results from the indexed results, the non-submatch results from the submatched results, the single results from the 'all' results, and the byte results from the string results. Therefore the table includes only the FindAllStringSubmatchIndex result. 

##### <a name="regexp-type-FindTest-String">func (t FindTest) String() string</a>

```Go
func (t FindTest) String() string
```

### <a name="regexp-func">Functions <small>(exported)</small></a>

#### <a name="regexp-func-freeBitState">func freeBitState(b *bitState)</a>

```Go
func freeBitState(b *bitState)
```

#### <a name="regexp-func-maxBitStateLen">func maxBitStateLen(prog *syntax.Prog) int</a>

```Go
func maxBitStateLen(prog *syntax.Prog) int
```

maxBitStateLen returns the maximum length of a string to search with the backtracker using prog. 

#### <a name="regexp-func-shouldBacktrack">func shouldBacktrack(prog *syntax.Prog) bool</a>

```Go
func shouldBacktrack(prog *syntax.Prog) bool
```

shouldBacktrack reports whether the program is too long for the backtracker to run. 

#### <a name="regexp-func-freeOnePassMachine">func freeOnePassMachine(m *onePassMachine)</a>

```Go
func freeOnePassMachine(m *onePassMachine)
```

#### <a name="regexp-func-onePassPrefix">func onePassPrefix(p *syntax.Prog) (prefix string, complete bool, pc uint32)</a>

```Go
func onePassPrefix(p *syntax.Prog) (prefix string, complete bool, pc uint32)
```

OnePassPrefix returns a literal string that all matches for the regexp must start with. Complete is true if the prefix is the entire match. Pc is the index of the last rune instruction in the string. The OnePassPrefix skips over the mandatory EmptyBeginText 

#### <a name="regexp-func-onePassNext">func onePassNext(i *onePassInst, r rune) uint32</a>

```Go
func onePassNext(i *onePassInst, r rune) uint32
```

OnePassNext selects the next actionable state of the prog, based on the input character. It should only be called when i.Op == InstAlt or InstAltMatch, and from the one-pass machine. One of the alternates may ultimately lead without input to end of line. If the instruction is InstAltMatch the path to the InstMatch is in i.Out, the normal node in i.Next. 

#### <a name="regexp-func-iop">func iop(i *syntax.Inst) syntax.InstOp</a>

```Go
func iop(i *syntax.Inst) syntax.InstOp
```

#### <a name="regexp-func-mergeRuneSets">func mergeRuneSets(leftRunes, rightRunes *[]rune, leftPC, rightPC uint32) ([]rune, []uint32)</a>

```Go
func mergeRuneSets(leftRunes, rightRunes *[]rune, leftPC, rightPC uint32) ([]rune, []uint32)
```

#### <a name="regexp-func-cleanupOnePass">func cleanupOnePass(prog *onePassProg, original *syntax.Prog)</a>

```Go
func cleanupOnePass(prog *onePassProg, original *syntax.Prog)
```

cleanupOnePass drops working memory, and restores certain shortcut instructions. 

#### <a name="regexp-func-minInputLen">func minInputLen(re *syntax.Regexp) int</a>

```Go
func minInputLen(re *syntax.Regexp) int
```

minInputLen walks the regexp to find the minimum length of any matchable input 

#### <a name="regexp-func-quote">func quote(s string) string</a>

```Go
func quote(s string) string
```

#### <a name="regexp-func-MatchReader">func MatchReader(pattern string, r io.RuneReader) (matched bool, err error) <small>(exported)</small></a>

```Go
func MatchReader(pattern string, r io.RuneReader) (matched bool, err error)
```

MatchReader reports whether the text returned by the RuneReader contains any match of the regular expression pattern. More complicated queries need to use Compile and the full Regexp interface. 

#### <a name="regexp-func-MatchString">func MatchString(pattern string, s string) (matched bool, err error) <small>(exported)</small></a>

```Go
func MatchString(pattern string, s string) (matched bool, err error)
```

MatchString reports whether the string s contains any match of the regular expression pattern. More complicated queries need to use Compile and the full Regexp interface. 

#### <a name="regexp-func-Match">func Match(pattern string, b []byte) (matched bool, err error) <small>(exported)</small></a>

```Go
func Match(pattern string, b []byte) (matched bool, err error)
```

Match reports whether the byte slice b contains any match of the regular expression pattern. More complicated queries need to use Compile and the full Regexp interface. 

#### <a name="regexp-func-special">func special(b byte) bool</a>

```Go
func special(b byte) bool
```

special reports whether byte b needs to be escaped by QuoteMeta. 

#### <a name="regexp-func-init">func init()</a>

```Go
func init()
```

#### <a name="regexp-func-QuoteMeta">func QuoteMeta(s string) string <small>(exported)</small></a>

```Go
func QuoteMeta(s string) string
```

QuoteMeta returns a string that escapes all regular expression metacharacters inside the argument text; the returned string is a regular expression matching the literal text. 

#### <a name="regexp-func-extract">func extract(str string) (name string, num int, rest string, ok bool)</a>

```Go
func extract(str string) (name string, num int, rest string, ok bool)
```

extract returns the name from a leading "$name" or "${name}" in str. If it is a number, extract returns num set to that number; otherwise num = -1. 

#### <a name="regexp-func-TestGoodCompile">func TestGoodCompile(t *testing.T)</a>

```Go
func TestGoodCompile(t *testing.T)
```

#### <a name="regexp-func-TestBadCompile">func TestBadCompile(t *testing.T)</a>

```Go
func TestBadCompile(t *testing.T)
```

#### <a name="regexp-func-matchTest">func matchTest(t *testing.T, test *FindTest)</a>

```Go
func matchTest(t *testing.T, test *FindTest)
```

#### <a name="regexp-func-TestMatch">func TestMatch(t *testing.T)</a>

```Go
func TestMatch(t *testing.T)
```

#### <a name="regexp-func-matchFunctionTest">func matchFunctionTest(t *testing.T, test *FindTest)</a>

```Go
func matchFunctionTest(t *testing.T, test *FindTest)
```

#### <a name="regexp-func-TestMatchFunction">func TestMatchFunction(t *testing.T)</a>

```Go
func TestMatchFunction(t *testing.T)
```

#### <a name="regexp-func-copyMatchTest">func copyMatchTest(t *testing.T, test *FindTest)</a>

```Go
func copyMatchTest(t *testing.T, test *FindTest)
```

#### <a name="regexp-func-TestCopyMatch">func TestCopyMatch(t *testing.T)</a>

```Go
func TestCopyMatch(t *testing.T)
```

#### <a name="regexp-func-TestReplaceAll">func TestReplaceAll(t *testing.T)</a>

```Go
func TestReplaceAll(t *testing.T)
```

#### <a name="regexp-func-TestReplaceAllLiteral">func TestReplaceAllLiteral(t *testing.T)</a>

```Go
func TestReplaceAllLiteral(t *testing.T)
```

#### <a name="regexp-func-TestReplaceAllFunc">func TestReplaceAllFunc(t *testing.T)</a>

```Go
func TestReplaceAllFunc(t *testing.T)
```

#### <a name="regexp-func-TestQuoteMeta">func TestQuoteMeta(t *testing.T)</a>

```Go
func TestQuoteMeta(t *testing.T)
```

#### <a name="regexp-func-TestLiteralPrefix">func TestLiteralPrefix(t *testing.T)</a>

```Go
func TestLiteralPrefix(t *testing.T)
```

#### <a name="regexp-func-TestSubexp">func TestSubexp(t *testing.T)</a>

```Go
func TestSubexp(t *testing.T)
```

#### <a name="regexp-func-TestSplit">func TestSplit(t *testing.T)</a>

```Go
func TestSplit(t *testing.T)
```

#### <a name="regexp-func-TestParseAndCompile">func TestParseAndCompile(t *testing.T)</a>

```Go
func TestParseAndCompile(t *testing.T)
```

The following sequence of Match calls used to panic. See issue #12980. 

#### <a name="regexp-func-TestOnePassCutoff">func TestOnePassCutoff(t *testing.T)</a>

```Go
func TestOnePassCutoff(t *testing.T)
```

Check that one-pass cutoff does trigger. 

#### <a name="regexp-func-TestSwitchBacktrack">func TestSwitchBacktrack(t *testing.T)</a>

```Go
func TestSwitchBacktrack(t *testing.T)
```

Check that the same machine can be used with the standard matcher and then the backtracker when there are no captures. 

#### <a name="regexp-func-BenchmarkFind">func BenchmarkFind(b *testing.B)</a>

```Go
func BenchmarkFind(b *testing.B)
```

#### <a name="regexp-func-BenchmarkFindAllNoMatches">func BenchmarkFindAllNoMatches(b *testing.B)</a>

```Go
func BenchmarkFindAllNoMatches(b *testing.B)
```

#### <a name="regexp-func-BenchmarkFindString">func BenchmarkFindString(b *testing.B)</a>

```Go
func BenchmarkFindString(b *testing.B)
```

#### <a name="regexp-func-BenchmarkFindSubmatch">func BenchmarkFindSubmatch(b *testing.B)</a>

```Go
func BenchmarkFindSubmatch(b *testing.B)
```

#### <a name="regexp-func-BenchmarkFindStringSubmatch">func BenchmarkFindStringSubmatch(b *testing.B)</a>

```Go
func BenchmarkFindStringSubmatch(b *testing.B)
```

#### <a name="regexp-func-BenchmarkLiteral">func BenchmarkLiteral(b *testing.B)</a>

```Go
func BenchmarkLiteral(b *testing.B)
```

#### <a name="regexp-func-BenchmarkNotLiteral">func BenchmarkNotLiteral(b *testing.B)</a>

```Go
func BenchmarkNotLiteral(b *testing.B)
```

#### <a name="regexp-func-BenchmarkMatchClass">func BenchmarkMatchClass(b *testing.B)</a>

```Go
func BenchmarkMatchClass(b *testing.B)
```

#### <a name="regexp-func-BenchmarkMatchClass_InRange">func BenchmarkMatchClass_InRange(b *testing.B)</a>

```Go
func BenchmarkMatchClass_InRange(b *testing.B)
```

#### <a name="regexp-func-BenchmarkReplaceAll">func BenchmarkReplaceAll(b *testing.B)</a>

```Go
func BenchmarkReplaceAll(b *testing.B)
```

#### <a name="regexp-func-BenchmarkAnchoredLiteralShortNonMatch">func BenchmarkAnchoredLiteralShortNonMatch(b *testing.B)</a>

```Go
func BenchmarkAnchoredLiteralShortNonMatch(b *testing.B)
```

#### <a name="regexp-func-BenchmarkAnchoredLiteralLongNonMatch">func BenchmarkAnchoredLiteralLongNonMatch(b *testing.B)</a>

```Go
func BenchmarkAnchoredLiteralLongNonMatch(b *testing.B)
```

#### <a name="regexp-func-BenchmarkAnchoredShortMatch">func BenchmarkAnchoredShortMatch(b *testing.B)</a>

```Go
func BenchmarkAnchoredShortMatch(b *testing.B)
```

#### <a name="regexp-func-BenchmarkAnchoredLongMatch">func BenchmarkAnchoredLongMatch(b *testing.B)</a>

```Go
func BenchmarkAnchoredLongMatch(b *testing.B)
```

#### <a name="regexp-func-BenchmarkOnePassShortA">func BenchmarkOnePassShortA(b *testing.B)</a>

```Go
func BenchmarkOnePassShortA(b *testing.B)
```

#### <a name="regexp-func-BenchmarkNotOnePassShortA">func BenchmarkNotOnePassShortA(b *testing.B)</a>

```Go
func BenchmarkNotOnePassShortA(b *testing.B)
```

#### <a name="regexp-func-BenchmarkOnePassShortB">func BenchmarkOnePassShortB(b *testing.B)</a>

```Go
func BenchmarkOnePassShortB(b *testing.B)
```

#### <a name="regexp-func-BenchmarkNotOnePassShortB">func BenchmarkNotOnePassShortB(b *testing.B)</a>

```Go
func BenchmarkNotOnePassShortB(b *testing.B)
```

#### <a name="regexp-func-BenchmarkOnePassLongPrefix">func BenchmarkOnePassLongPrefix(b *testing.B)</a>

```Go
func BenchmarkOnePassLongPrefix(b *testing.B)
```

#### <a name="regexp-func-BenchmarkOnePassLongNotPrefix">func BenchmarkOnePassLongNotPrefix(b *testing.B)</a>

```Go
func BenchmarkOnePassLongNotPrefix(b *testing.B)
```

#### <a name="regexp-func-BenchmarkMatchParallelShared">func BenchmarkMatchParallelShared(b *testing.B)</a>

```Go
func BenchmarkMatchParallelShared(b *testing.B)
```

#### <a name="regexp-func-BenchmarkMatchParallelCopied">func BenchmarkMatchParallelCopied(b *testing.B)</a>

```Go
func BenchmarkMatchParallelCopied(b *testing.B)
```

#### <a name="regexp-func-BenchmarkQuoteMetaAll">func BenchmarkQuoteMetaAll(b *testing.B)</a>

```Go
func BenchmarkQuoteMetaAll(b *testing.B)
```

#### <a name="regexp-func-BenchmarkQuoteMetaNone">func BenchmarkQuoteMetaNone(b *testing.B)</a>

```Go
func BenchmarkQuoteMetaNone(b *testing.B)
```

#### <a name="regexp-func-BenchmarkCompile">func BenchmarkCompile(b *testing.B)</a>

```Go
func BenchmarkCompile(b *testing.B)
```

#### <a name="regexp-func-TestDeepEqual">func TestDeepEqual(t *testing.T)</a>

```Go
func TestDeepEqual(t *testing.T)
```

#### <a name="regexp-func-TestMinInputLen">func TestMinInputLen(t *testing.T)</a>

```Go
func TestMinInputLen(t *testing.T)
```

#### <a name="regexp-func-TestRE2Exhaustive">func TestRE2Exhaustive(t *testing.T)</a>

```Go
func TestRE2Exhaustive(t *testing.T)
```

This test is excluded when running under the race detector because it is a very expensive test and takes too long. 

#### <a name="regexp-func-TestRE2Search">func TestRE2Search(t *testing.T)</a>

```Go
func TestRE2Search(t *testing.T)
```

TestRE2 tests this package's regexp API against test cases considered during RE2's exhaustive tests, which run all possible regexps over a given set of atoms and operators, up to a given complexity, over all possible strings over a given alphabet, up to a given size. Rather than try to link with RE2, we read a log file containing the test cases and the expected matches. The log file, re2-exhaustive.txt, is generated by running 'make log' in the open source RE2 distribution [https://github.com/google/re2/](https://github.com/google/re2/). 

The test file format is a sequence of stanzas like: 

```
strings
"abc"
"123x"
regexps
"[a-z]+"
0-3;0-3
-;-
"([0-9])([0-9])([0-9])"
-;-
-;0-3 0-1 1-2 2-3

```
The stanza begins by defining a set of strings, quoted using Go double-quote syntax, one per line. Then the regexps section gives a sequence of regexps to run on the strings. In the block that follows a regexp, each line gives the semicolon-separated match results of running the regexp on the corresponding string. Each match result is either a single -, meaning no match, or a space-separated sequence of pairs giving the match and submatch indices. An unmatched subexpression formats its pair as a single - (not illustrated above).  For now each regexp run produces two match results, one for a `full match' that restricts the regexp to matching the entire string or nothing, and one for a `partial match' that gives the leftmost first match found in the string. 

Lines beginning with # are comments. Lines beginning with a capital letter are test names printed during RE2's test suite and are echoed into t but otherwise ignored. 

At time of writing, re2-exhaustive.txt is 59 MB but compresses to 385 kB, so we store re2-exhaustive.txt.bz2 in the repository and decompress it on the fly. 

#### <a name="regexp-func-testRE2">func testRE2(t *testing.T, file string)</a>

```Go
func testRE2(t *testing.T, file string)
```

#### <a name="regexp-func-runFull">func runFull(re, refull *Regexp, text string) ([]int, string)</a>

```Go
func runFull(re, refull *Regexp, text string) ([]int, string)
```

#### <a name="regexp-func-runPartial">func runPartial(re, refull *Regexp, text string) ([]int, string)</a>

```Go
func runPartial(re, refull *Regexp, text string) ([]int, string)
```

#### <a name="regexp-func-runFullLongest">func runFullLongest(re, refull *Regexp, text string) ([]int, string)</a>

```Go
func runFullLongest(re, refull *Regexp, text string) ([]int, string)
```

#### <a name="regexp-func-runPartialLongest">func runPartialLongest(re, refull *Regexp, text string) ([]int, string)</a>

```Go
func runPartialLongest(re, refull *Regexp, text string) ([]int, string)
```

#### <a name="regexp-func-matchFull">func matchFull(re, refull *Regexp, text string) (bool, string)</a>

```Go
func matchFull(re, refull *Regexp, text string) (bool, string)
```

#### <a name="regexp-func-matchPartial">func matchPartial(re, refull *Regexp, text string) (bool, string)</a>

```Go
func matchPartial(re, refull *Regexp, text string) (bool, string)
```

#### <a name="regexp-func-matchFullLongest">func matchFullLongest(re, refull *Regexp, text string) (bool, string)</a>

```Go
func matchFullLongest(re, refull *Regexp, text string) (bool, string)
```

#### <a name="regexp-func-matchPartialLongest">func matchPartialLongest(re, refull *Regexp, text string) (bool, string)</a>

```Go
func matchPartialLongest(re, refull *Regexp, text string) (bool, string)
```

#### <a name="regexp-func-isSingleBytes">func isSingleBytes(s string) bool</a>

```Go
func isSingleBytes(s string) bool
```

#### <a name="regexp-func-parseResult">func parseResult(t *testing.T, file string, lineno int, res string) []int</a>

```Go
func parseResult(t *testing.T, file string, lineno int, res string) []int
```

#### <a name="regexp-func-same">func same(x, y []int) bool</a>

```Go
func same(x, y []int) bool
```

#### <a name="regexp-func-TestFowler">func TestFowler(t *testing.T)</a>

```Go
func TestFowler(t *testing.T)
```

TestFowler runs this package's regexp API against the POSIX regular expression tests collected by Glenn Fowler at [http://www2.research.att.com/~astopen/testregex/testregex.html](http://www2.research.att.com/~astopen/testregex/testregex.html). 

#### <a name="regexp-func-testFowler">func testFowler(t *testing.T, file string)</a>

```Go
func testFowler(t *testing.T, file string)
```

#### <a name="regexp-func-parseFowlerResult">func parseFowlerResult(s string) (ok, compiled, matched bool, pos []int)</a>

```Go
func parseFowlerResult(s string) (ok, compiled, matched bool, pos []int)
```

#### <a name="regexp-func-makeText">func makeText(n int) []byte</a>

```Go
func makeText(n int) []byte
```

#### <a name="regexp-func-BenchmarkMatch">func BenchmarkMatch(b *testing.B)</a>

```Go
func BenchmarkMatch(b *testing.B)
```

#### <a name="regexp-func-BenchmarkMatch_onepass_regex">func BenchmarkMatch_onepass_regex(b *testing.B)</a>

```Go
func BenchmarkMatch_onepass_regex(b *testing.B)
```

#### <a name="regexp-func-TestLongest">func TestLongest(t *testing.T)</a>

```Go
func TestLongest(t *testing.T)
```

#### <a name="regexp-func-TestProgramTooLongForBacktrack">func TestProgramTooLongForBacktrack(t *testing.T)</a>

```Go
func TestProgramTooLongForBacktrack(t *testing.T)
```

TestProgramTooLongForBacktrack tests that a regex which is too long for the backtracker still executes properly. 

#### <a name="regexp-func-build">func build(n int, x ...int) [][]int</a>

```Go
func build(n int, x ...int) [][]int
```

build is a helper to construct a [][]int by extracting n sequences from x. This represents n matches with len(x)/n submatches each. 

#### <a name="regexp-func-TestFind">func TestFind(t *testing.T)</a>

```Go
func TestFind(t *testing.T)
```

#### <a name="regexp-func-TestFindString">func TestFindString(t *testing.T)</a>

```Go
func TestFindString(t *testing.T)
```

#### <a name="regexp-func-testFindIndex">func testFindIndex(test *FindTest, result []int, t *testing.T)</a>

```Go
func testFindIndex(test *FindTest, result []int, t *testing.T)
```

#### <a name="regexp-func-TestFindIndex">func TestFindIndex(t *testing.T)</a>

```Go
func TestFindIndex(t *testing.T)
```

#### <a name="regexp-func-TestFindStringIndex">func TestFindStringIndex(t *testing.T)</a>

```Go
func TestFindStringIndex(t *testing.T)
```

#### <a name="regexp-func-TestFindReaderIndex">func TestFindReaderIndex(t *testing.T)</a>

```Go
func TestFindReaderIndex(t *testing.T)
```

#### <a name="regexp-func-TestFindAll">func TestFindAll(t *testing.T)</a>

```Go
func TestFindAll(t *testing.T)
```

#### <a name="regexp-func-TestFindAllString">func TestFindAllString(t *testing.T)</a>

```Go
func TestFindAllString(t *testing.T)
```

#### <a name="regexp-func-testFindAllIndex">func testFindAllIndex(test *FindTest, result [][]int, t *testing.T)</a>

```Go
func testFindAllIndex(test *FindTest, result [][]int, t *testing.T)
```

#### <a name="regexp-func-TestFindAllIndex">func TestFindAllIndex(t *testing.T)</a>

```Go
func TestFindAllIndex(t *testing.T)
```

#### <a name="regexp-func-TestFindAllStringIndex">func TestFindAllStringIndex(t *testing.T)</a>

```Go
func TestFindAllStringIndex(t *testing.T)
```

#### <a name="regexp-func-testSubmatchBytes">func testSubmatchBytes(test *FindTest, n int, submatches []int, result [][]byte, t *testing.T)</a>

```Go
func testSubmatchBytes(test *FindTest, n int, submatches []int, result [][]byte, t *testing.T)
```

#### <a name="regexp-func-TestFindSubmatch">func TestFindSubmatch(t *testing.T)</a>

```Go
func TestFindSubmatch(t *testing.T)
```

#### <a name="regexp-func-testSubmatchString">func testSubmatchString(test *FindTest, n int, submatches []int, result []string, t *testing.T)</a>

```Go
func testSubmatchString(test *FindTest, n int, submatches []int, result []string, t *testing.T)
```

#### <a name="regexp-func-TestFindStringSubmatch">func TestFindStringSubmatch(t *testing.T)</a>

```Go
func TestFindStringSubmatch(t *testing.T)
```

#### <a name="regexp-func-testSubmatchIndices">func testSubmatchIndices(test *FindTest, n int, expect, result []int, t *testing.T)</a>

```Go
func testSubmatchIndices(test *FindTest, n int, expect, result []int, t *testing.T)
```

#### <a name="regexp-func-testFindSubmatchIndex">func testFindSubmatchIndex(test *FindTest, result []int, t *testing.T)</a>

```Go
func testFindSubmatchIndex(test *FindTest, result []int, t *testing.T)
```

#### <a name="regexp-func-TestFindSubmatchIndex">func TestFindSubmatchIndex(t *testing.T)</a>

```Go
func TestFindSubmatchIndex(t *testing.T)
```

#### <a name="regexp-func-TestFindStringSubmatchIndex">func TestFindStringSubmatchIndex(t *testing.T)</a>

```Go
func TestFindStringSubmatchIndex(t *testing.T)
```

#### <a name="regexp-func-TestFindReaderSubmatchIndex">func TestFindReaderSubmatchIndex(t *testing.T)</a>

```Go
func TestFindReaderSubmatchIndex(t *testing.T)
```

#### <a name="regexp-func-TestFindAllSubmatch">func TestFindAllSubmatch(t *testing.T)</a>

```Go
func TestFindAllSubmatch(t *testing.T)
```

#### <a name="regexp-func-TestFindAllStringSubmatch">func TestFindAllStringSubmatch(t *testing.T)</a>

```Go
func TestFindAllStringSubmatch(t *testing.T)
```

#### <a name="regexp-func-testFindAllSubmatchIndex">func testFindAllSubmatchIndex(test *FindTest, result [][]int, t *testing.T)</a>

```Go
func testFindAllSubmatchIndex(test *FindTest, result [][]int, t *testing.T)
```

#### <a name="regexp-func-TestFindAllSubmatchIndex">func TestFindAllSubmatchIndex(t *testing.T)</a>

```Go
func TestFindAllSubmatchIndex(t *testing.T)
```

#### <a name="regexp-func-TestFindAllStringSubmatchIndex">func TestFindAllStringSubmatchIndex(t *testing.T)</a>

```Go
func TestFindAllStringSubmatchIndex(t *testing.T)
```

#### <a name="regexp-func-TestMergeRuneSet">func TestMergeRuneSet(t *testing.T)</a>

```Go
func TestMergeRuneSet(t *testing.T)
```

#### <a name="regexp-func-TestCompileOnePass">func TestCompileOnePass(t *testing.T)</a>

```Go
func TestCompileOnePass(t *testing.T)
```

#### <a name="regexp-func-TestRunOnePass">func TestRunOnePass(t *testing.T)</a>

```Go
func TestRunOnePass(t *testing.T)
```

## <a name="syntax">Package syntax <small>(new page,exported)</small></a>

Package syntax parses regular expressions into parse trees and compiles parse trees into programs. Most clients of regular expressions will use the facilities of package regexp (such as Compile and Match) instead of this package. 

### hdr-SyntaxSyntax
The regular expression syntax understood by this package when parsing with the Perl flag is as follows. Parts of the syntax can be disabled by passing alternate flags to Parse. 

Single characters: 

```
.              any character, possibly including newline (flag s=true)
[xyz]          character class
[^xyz]         negated character class
\d             Perl character class
\D             negated Perl character class
[[:alpha:]]    ASCII character class
[[:^alpha:]]   negated ASCII character class
\pN            Unicode character class (one-letter name)
\p{Greek}      Unicode character class
\PN            negated Unicode character class (one-letter name)
\P{Greek}      negated Unicode character class

```
Composites: 

```
xy             x followed by y
x|y            x or y (prefer x)

```
Repetitions: 

```
x*             zero or more x, prefer more
x+             one or more x, prefer more
x?             zero or one x, prefer one
x{n,m}         n or n+1 or ... or m x, prefer more
x{n,}          n or more x, prefer more
x{n}           exactly n x
x*?            zero or more x, prefer fewer
x+?            one or more x, prefer fewer
x??            zero or one x, prefer zero
x{n,m}?        n or n+1 or ... or m x, prefer fewer
x{n,}?         n or more x, prefer fewer
x{n}?          exactly n x

```
Implementation restriction: The counting forms x{n,m}, x{n,}, and x{n} reject forms that create a minimum or maximum repetition count above 1000. Unlimited repetitions are not subject to this restriction. 

Grouping: 

```
(re)           numbered capturing group (submatch)
(?P<name>re)   named & numbered capturing group (submatch)
(?:re)         non-capturing group
(?flags)       set flags within current group; non-capturing
(?flags:re)    set flags during re; non-capturing

Flag syntax is xyz (set) or -xyz (clear) or xy-z (set xy, clear z). The flags are:

i              case-insensitive (default false)
m              multi-line mode: ^ and $ match begin/end line in addition to begin/end text (default false)
s              let . match \n (default false)
U              ungreedy: swap meaning of x* and x*?, x+ and x+?, etc (default false)

```
Empty strings: 

```
^              at beginning of text or line (flag m=true)
$              at end of text (like \z not \Z) or line (flag m=true)
\A             at beginning of text
\b             at ASCII word boundary (\w on one side and \W, \A, or \z on the other)
\B             not at ASCII word boundary
\z             at end of text

```
Escape sequences: 

```
\a             bell (== \007)
\f             form feed (== \014)
\t             horizontal tab (== \011)
\n             newline (== \012)
\r             carriage return (== \015)
\v             vertical tab character (== \013)
\*             literal *, for any punctuation character *
\123           octal character code (up to three digits)
\x7F           hex character code (exactly two digits)
\x{10FFFF}     hex character code
\Q...\E        literal text ... even if ... has punctuation

```
Character class elements: 

```
x              single character
A-Z            character range (inclusive)
\d             Perl character class
[:foo:]        ASCII character class foo
\p{Foo}        Unicode character class Foo
\pF            Unicode character class F (one-letter name)

```
Named character classes as character class elements: 

```
[\d]           digits (== \d)
[^\d]          not digits (== \D)
[\D]           not digits (== \D)
[^\D]          not not digits (== \d)
[[:name:]]     named ASCII class inside character class (== [:name:])
[^[:name:]]    named ASCII class inside negated character class (== [:^name:])
[\p{Name}]     named Unicode property inside character class (== \p{Name})
[^\p{Name}]    named Unicode property inside negated character class (== \P{Name})

```
Perl character classes (all ASCII-only): 

```
\d             digits (== [0-9])
\D             not digits (== [^0-9])
\s             whitespace (== [\t\n\f\r ])
\S             not whitespace (== [^\t\n\f\r ])
\w             word characters (== [0-9A-Za-z_])
\W             not word characters (== [^0-9A-Za-z_])

```
ASCII character classes: 

```
[[:alnum:]]    alphanumeric (== [0-9A-Za-z])
[[:alpha:]]    alphabetic (== [A-Za-z])
[[:ascii:]]    ASCII (== [\x00-\x7F])
[[:blank:]]    blank (== [\t ])
[[:cntrl:]]    control (== [\x00-\x1F\x7F])
[[:digit:]]    digits (== [0-9])
[[:graph:]]    graphical (== [!-~] == [A-Za-z0-9!"#$%&'()*+,\-./:;<=>?@[\\\]^_`{|}~])
[[:lower:]]    lower case (== [a-z])
[[:print:]]    printable (== [ -~] == [ [:graph:]])
[[:punct:]]    punctuation (== [!-/:-@[-`{-~])
[[:space:]]    whitespace (== [\t\n\v\f\r ])
[[:upper:]]    upper case (== [A-Z])
[[:word:]]     word characters (== [0-9A-Za-z_])
[[:xdigit:]]   hex digit (== [0-9A-Fa-f])

```
Unicode character classes are those in unicode.Categories and unicode.Scripts. 

## Index

- [Constants](#syntax-const)
  - [const _Op_name_0](#syntax-const-_Op_name_0)
  - [const _Op_name_1](#syntax-const-_Op_name_1)
  - [const ErrInternalError](#syntax-const-ErrInternalError)
  - [const ErrInvalidCharClass](#syntax-const-ErrInvalidCharClass)
  - [const ErrInvalidCharRange](#syntax-const-ErrInvalidCharRange)
  - [const ErrInvalidEscape](#syntax-const-ErrInvalidEscape)
  - [const ErrInvalidNamedCapture](#syntax-const-ErrInvalidNamedCapture)
  - [const ErrInvalidPerlOp](#syntax-const-ErrInvalidPerlOp)
  - [const ErrInvalidRepeatOp](#syntax-const-ErrInvalidRepeatOp)
  - [const ErrInvalidRepeatSize](#syntax-const-ErrInvalidRepeatSize)
  - [const ErrInvalidUTF8](#syntax-const-ErrInvalidUTF8)
  - [const ErrMissingBracket](#syntax-const-ErrMissingBracket)
  - [const ErrMissingParen](#syntax-const-ErrMissingParen)
  - [const ErrMissingRepeatArgument](#syntax-const-ErrMissingRepeatArgument)
  - [const ErrTrailingBackslash](#syntax-const-ErrTrailingBackslash)
  - [const ErrUnexpectedParen](#syntax-const-ErrUnexpectedParen)
  - [const FoldCase](#syntax-const-FoldCase)
  - [const Literal](#syntax-const-Literal)
  - [const ClassNL](#syntax-const-ClassNL)
  - [const DotNL](#syntax-const-DotNL)
  - [const OneLine](#syntax-const-OneLine)
  - [const NonGreedy](#syntax-const-NonGreedy)
  - [const PerlX](#syntax-const-PerlX)
  - [const UnicodeGroups](#syntax-const-UnicodeGroups)
  - [const WasDollar](#syntax-const-WasDollar)
  - [const Simple](#syntax-const-Simple)
  - [const MatchNL](#syntax-const-MatchNL)
  - [const Perl](#syntax-const-Perl)
  - [const POSIX](#syntax-const-POSIX)
  - [const opLeftParen](#syntax-const-opLeftParen)
  - [const opVerticalBar](#syntax-const-opVerticalBar)
  - [const minFold](#syntax-const-minFold)
  - [const maxFold](#syntax-const-maxFold)
  - [const InstAlt](#syntax-const-InstAlt)
  - [const InstAltMatch](#syntax-const-InstAltMatch)
  - [const InstCapture](#syntax-const-InstCapture)
  - [const InstEmptyWidth](#syntax-const-InstEmptyWidth)
  - [const InstMatch](#syntax-const-InstMatch)
  - [const InstFail](#syntax-const-InstFail)
  - [const InstNop](#syntax-const-InstNop)
  - [const InstRune](#syntax-const-InstRune)
  - [const InstRune1](#syntax-const-InstRune1)
  - [const InstRuneAny](#syntax-const-InstRuneAny)
  - [const InstRuneAnyNotNL](#syntax-const-InstRuneAnyNotNL)
  - [const EmptyBeginLine](#syntax-const-EmptyBeginLine)
  - [const EmptyEndLine](#syntax-const-EmptyEndLine)
  - [const EmptyBeginText](#syntax-const-EmptyBeginText)
  - [const EmptyEndText](#syntax-const-EmptyEndText)
  - [const EmptyWordBoundary](#syntax-const-EmptyWordBoundary)
  - [const EmptyNoWordBoundary](#syntax-const-EmptyNoWordBoundary)
  - [const noMatch](#syntax-const-noMatch)
  - [const OpNoMatch](#syntax-const-OpNoMatch)
  - [const OpEmptyMatch](#syntax-const-OpEmptyMatch)
  - [const OpLiteral](#syntax-const-OpLiteral)
  - [const OpCharClass](#syntax-const-OpCharClass)
  - [const OpAnyCharNotNL](#syntax-const-OpAnyCharNotNL)
  - [const OpAnyChar](#syntax-const-OpAnyChar)
  - [const OpBeginLine](#syntax-const-OpBeginLine)
  - [const OpEndLine](#syntax-const-OpEndLine)
  - [const OpBeginText](#syntax-const-OpBeginText)
  - [const OpEndText](#syntax-const-OpEndText)
  - [const OpWordBoundary](#syntax-const-OpWordBoundary)
  - [const OpNoWordBoundary](#syntax-const-OpNoWordBoundary)
  - [const OpCapture](#syntax-const-OpCapture)
  - [const OpStar](#syntax-const-OpStar)
  - [const OpPlus](#syntax-const-OpPlus)
  - [const OpQuest](#syntax-const-OpQuest)
  - [const OpRepeat](#syntax-const-OpRepeat)
  - [const OpConcat](#syntax-const-OpConcat)
  - [const OpAlternate](#syntax-const-OpAlternate)
  - [const opPseudo](#syntax-const-opPseudo)
  - [const meta](#syntax-const-meta)
  - [const testFlags](#syntax-const-testFlags)
- [Variables](#syntax-var)
  - [var c](#syntax-var-c)
  - [var anyRuneNotNL](#syntax-var-anyRuneNotNL)
  - [var anyRune](#syntax-var-anyRune)
  - [var f](#syntax-var-f)
  - [var f](#syntax-var-f)
  - [var f](#syntax-var-f)
  - [var _Op_index_0](#syntax-var-_Op_index_0)
  - [var str](#syntax-var-str)
  - [var strflags](#syntax-var-strflags)
  - [var istr](#syntax-var-istr)
  - [var iflags](#syntax-var-iflags)
  - [var first](#syntax-var-first)
  - [var ifirst](#syntax-var-ifirst)
  - [var p](#syntax-var-p)
  - [var err](#syntax-var-err)
  - [var c](#syntax-var-c)
  - [var op](#syntax-var-op)
  - [var lastRepeat](#syntax-var-lastRepeat)
  - [var lit](#syntax-var-lit)
  - [var ok1](#syntax-var-ok1)
  - [var c](#syntax-var-c)
  - [var anyTable](#syntax-var-anyTable)
  - [var seq](#syntax-var-seq)
  - [var name](#syntax-var-name)
  - [var lo](#syntax-var-lo)
  - [var hi](#syntax-var-hi)
  - [var code1](#syntax-var-code1)
  - [var code2](#syntax-var-code2)
  - [var code3](#syntax-var-code3)
  - [var perlGroup](#syntax-var-perlGroup)
  - [var code4](#syntax-var-code4)
  - [var code5](#syntax-var-code5)
  - [var code6](#syntax-var-code6)
  - [var code7](#syntax-var-code7)
  - [var code8](#syntax-var-code8)
  - [var code9](#syntax-var-code9)
  - [var code10](#syntax-var-code10)
  - [var code11](#syntax-var-code11)
  - [var code12](#syntax-var-code12)
  - [var code13](#syntax-var-code13)
  - [var code14](#syntax-var-code14)
  - [var code15](#syntax-var-code15)
  - [var code16](#syntax-var-code16)
  - [var code17](#syntax-var-code17)
  - [var posixGroup](#syntax-var-posixGroup)
  - [var instOpNames](#syntax-var-instOpNames)
  - [var op](#syntax-var-op)
  - [var boundary](#syntax-var-boundary)
  - [var b](#syntax-var-b)
  - [var buf](#syntax-var-buf)
  - [var flag](#syntax-var-flag)
  - [var b](#syntax-var-b)
  - [var b](#syntax-var-b)
  - [var prefix](#syntax-var-prefix)
  - [var parseTests](#syntax-var-parseTests)
  - [var foldcaseTests](#syntax-var-foldcaseTests)
  - [var literalTests](#syntax-var-literalTests)
  - [var matchnlTests](#syntax-var-matchnlTests)
  - [var nomatchnlTests](#syntax-var-nomatchnlTests)
  - [var b](#syntax-var-b)
  - [var opNames](#syntax-var-opNames)
  - [var r](#syntax-var-r)
  - [var invalidRegexps](#syntax-var-invalidRegexps)
  - [var onlyPerl](#syntax-var-onlyPerl)
  - [var onlyPOSIX](#syntax-var-onlyPOSIX)
  - [var compileTests](#syntax-var-compileTests)
  - [var r1](#syntax-var-r1)
  - [var simplifyTests](#syntax-var-simplifyTests)
- [Types](#syntax-type)
  - [type patchList struct](#syntax-type-patchList)
    - [func makePatchList(n uint32) patchList](#syntax-type-patchList-makePatchList)
    - [func (l patchList) patch(p *Prog, val uint32)](#syntax-type-patchList-patch)
    - [func (l1 patchList) append(p *Prog, l2 patchList) patchList](#syntax-type-patchList-append)
  - [type frag struct](#syntax-type-frag)
  - [type compiler struct](#syntax-type-compiler)
    - [func (c *compiler) init()](#syntax-type-compiler-init)
    - [func (c *compiler) compile(re *Regexp) frag](#syntax-type-compiler-compile)
    - [func (c *compiler) inst(op InstOp) frag](#syntax-type-compiler-inst)
    - [func (c *compiler) nop() frag](#syntax-type-compiler-nop)
    - [func (c *compiler) fail() frag](#syntax-type-compiler-fail)
    - [func (c *compiler) cap(arg uint32) frag](#syntax-type-compiler-cap)
    - [func (c *compiler) cat(f1, f2 frag) frag](#syntax-type-compiler-cat)
    - [func (c *compiler) alt(f1, f2 frag) frag](#syntax-type-compiler-alt)
    - [func (c *compiler) quest(f1 frag, nongreedy bool) frag](#syntax-type-compiler-quest)
    - [func (c *compiler) star(f1 frag, nongreedy bool) frag](#syntax-type-compiler-star)
    - [func (c *compiler) plus(f1 frag, nongreedy bool) frag](#syntax-type-compiler-plus)
    - [func (c *compiler) empty(op EmptyOp) frag](#syntax-type-compiler-empty)
    - [func (c *compiler) rune(r []rune, flags Flags) frag](#syntax-type-compiler-rune)
  - [type Error struct](#syntax-type-Error)
    - [func (e *Error) Error() string](#syntax-type-Error-Error)
  - [type ErrorCode string](#syntax-type-ErrorCode)
    - [func (e ErrorCode) String() string](#syntax-type-ErrorCode-String)
  - [type Flags uint16](#syntax-type-Flags)
  - [type parser struct](#syntax-type-parser)
    - [func (p *parser) newRegexp(op Op) *Regexp](#syntax-type-parser-newRegexp)
    - [func (p *parser) reuse(re *Regexp)](#syntax-type-parser-reuse)
    - [func (p *parser) push(re *Regexp) *Regexp](#syntax-type-parser-push)
    - [func (p *parser) maybeConcat(r rune, flags Flags) bool](#syntax-type-parser-maybeConcat)
    - [func (p *parser) literal(r rune)](#syntax-type-parser-literal)
    - [func (p *parser) op(op Op) *Regexp](#syntax-type-parser-op)
    - [func (p *parser) repeat(op Op, min, max int, before, after, lastRepeat string) (string, error)](#syntax-type-parser-repeat)
    - [func (p *parser) concat() *Regexp](#syntax-type-parser-concat)
    - [func (p *parser) alternate() *Regexp](#syntax-type-parser-alternate)
    - [func (p *parser) collapse(subs []*Regexp, op Op) *Regexp](#syntax-type-parser-collapse)
    - [func (p *parser) factor(sub []*Regexp) []*Regexp](#syntax-type-parser-factor)
    - [func (p *parser) leadingString(re *Regexp) ([]rune, Flags)](#syntax-type-parser-leadingString)
    - [func (p *parser) removeLeadingString(re *Regexp, n int) *Regexp](#syntax-type-parser-removeLeadingString)
    - [func (p *parser) leadingRegexp(re *Regexp) *Regexp](#syntax-type-parser-leadingRegexp)
    - [func (p *parser) removeLeadingRegexp(re *Regexp, reuse bool) *Regexp](#syntax-type-parser-removeLeadingRegexp)
    - [func (p *parser) parseRepeat(s string) (min, max int, rest string, ok bool)](#syntax-type-parser-parseRepeat)
    - [func (p *parser) parsePerlFlags(s string) (rest string, err error)](#syntax-type-parser-parsePerlFlags)
    - [func (p *parser) parseInt(s string) (n int, rest string, ok bool)](#syntax-type-parser-parseInt)
    - [func (p *parser) parseVerticalBar() error](#syntax-type-parser-parseVerticalBar)
    - [func (p *parser) swapVerticalBar() bool](#syntax-type-parser-swapVerticalBar)
    - [func (p *parser) parseRightParen() error](#syntax-type-parser-parseRightParen)
    - [func (p *parser) parseEscape(s string) (r rune, rest string, err error)](#syntax-type-parser-parseEscape)
    - [func (p *parser) parseClassChar(s, wholeClass string) (r rune, rest string, err error)](#syntax-type-parser-parseClassChar)
    - [func (p *parser) parsePerlClassEscape(s string, r []rune) (out []rune, rest string)](#syntax-type-parser-parsePerlClassEscape)
    - [func (p *parser) parseNamedClass(s string, r []rune) (out []rune, rest string, err error)](#syntax-type-parser-parseNamedClass)
    - [func (p *parser) appendGroup(r []rune, g charGroup) []rune](#syntax-type-parser-appendGroup)
    - [func (p *parser) parseUnicodeClass(s string, r []rune) (out []rune, rest string, err error)](#syntax-type-parser-parseUnicodeClass)
    - [func (p *parser) parseClass(s string) (rest string, err error)](#syntax-type-parser-parseClass)
  - [type charGroup struct](#syntax-type-charGroup)
  - [type ranges struct](#syntax-type-ranges)
    - [func (ra ranges) Less(i, j int) bool](#syntax-type-ranges-Less)
    - [func (ra ranges) Len() int](#syntax-type-ranges-Len)
    - [func (ra ranges) Swap(i, j int)](#syntax-type-ranges-Swap)
  - [type Prog struct](#syntax-type-Prog)
    - [func Compile(re *Regexp) (*Prog, error)](#syntax-type-Prog-Compile)
    - [func (p *Prog) String() string](#syntax-type-Prog-String)
    - [func (p *Prog) skipNop(pc uint32) *Inst](#syntax-type-Prog-skipNop)
    - [func (p *Prog) Prefix() (prefix string, complete bool)](#syntax-type-Prog-Prefix)
    - [func (p *Prog) StartCond() EmptyOp](#syntax-type-Prog-StartCond)
  - [type InstOp uint8](#syntax-type-InstOp)
    - [func (i InstOp) String() string](#syntax-type-InstOp-String)
  - [type EmptyOp uint8](#syntax-type-EmptyOp)
    - [func EmptyOpContext(r1, r2 rune) EmptyOp](#syntax-type-EmptyOp-EmptyOpContext)
  - [type Inst struct](#syntax-type-Inst)
    - [func (i *Inst) op() InstOp](#syntax-type-Inst-op)
    - [func (i *Inst) MatchRune(r rune) bool](#syntax-type-Inst-MatchRune)
    - [func (i *Inst) MatchRunePos(r rune) int](#syntax-type-Inst-MatchRunePos)
    - [func (i *Inst) MatchEmptyWidth(before rune, after rune) bool](#syntax-type-Inst-MatchEmptyWidth)
    - [func (i *Inst) String() string](#syntax-type-Inst-String)
  - [type Regexp struct](#syntax-type-Regexp)
    - [func literalRegexp(s string, flags Flags) *Regexp](#syntax-type-Regexp-literalRegexp)
    - [func Parse(s string, flags Flags) (*Regexp, error)](#syntax-type-Regexp-Parse)
    - [func simplify1(op Op, flags Flags, sub, re *Regexp) *Regexp](#syntax-type-Regexp-simplify1)
    - [func (x *Regexp) Equal(y *Regexp) bool](#syntax-type-Regexp-Equal)
    - [func (re *Regexp) String() string](#syntax-type-Regexp-String)
    - [func (re *Regexp) MaxCap() int](#syntax-type-Regexp-MaxCap)
    - [func (re *Regexp) CapNames() []string](#syntax-type-Regexp-CapNames)
    - [func (re *Regexp) capNames(names []string)](#syntax-type-Regexp-capNames)
    - [func (re *Regexp) Simplify() *Regexp](#syntax-type-Regexp-Simplify)
  - [type Op uint8](#syntax-type-Op)
    - [func (i Op) String() string](#syntax-type-Op-String)
  - [type parseTest struct](#syntax-type-parseTest)
- [Functions](#syntax-func)
  - [func minFoldRune(r rune) rune](#syntax-func-minFoldRune)
  - [func repeatIsValid(re *Regexp, n int) bool](#syntax-func-repeatIsValid)
  - [func cleanAlt(re *Regexp)](#syntax-func-cleanAlt)
  - [func isValidCaptureName(name string) bool](#syntax-func-isValidCaptureName)
  - [func isCharClass(re *Regexp) bool](#syntax-func-isCharClass)
  - [func matchRune(re *Regexp, r rune) bool](#syntax-func-matchRune)
  - [func mergeCharClass(dst, src *Regexp)](#syntax-func-mergeCharClass)
  - [func unicodeTable(name string) (*unicode.RangeTable, *unicode.RangeTable)](#syntax-func-unicodeTable)
  - [func cleanClass(rp *[]rune) []rune](#syntax-func-cleanClass)
  - [func appendLiteral(r []rune, x rune, flags Flags) []rune](#syntax-func-appendLiteral)
  - [func appendRange(r []rune, lo, hi rune) []rune](#syntax-func-appendRange)
  - [func appendFoldedRange(r []rune, lo, hi rune) []rune](#syntax-func-appendFoldedRange)
  - [func appendClass(r []rune, x []rune) []rune](#syntax-func-appendClass)
  - [func appendFoldedClass(r []rune, x []rune) []rune](#syntax-func-appendFoldedClass)
  - [func appendNegatedClass(r []rune, x []rune) []rune](#syntax-func-appendNegatedClass)
  - [func appendTable(r []rune, x *unicode.RangeTable) []rune](#syntax-func-appendTable)
  - [func appendNegatedTable(r []rune, x *unicode.RangeTable) []rune](#syntax-func-appendNegatedTable)
  - [func negateClass(r []rune) []rune](#syntax-func-negateClass)
  - [func checkUTF8(s string) error](#syntax-func-checkUTF8)
  - [func nextRune(s string) (c rune, t string, err error)](#syntax-func-nextRune)
  - [func isalnum(c rune) bool](#syntax-func-isalnum)
  - [func unhex(c rune) rune](#syntax-func-unhex)
  - [func IsWordChar(r rune) bool](#syntax-func-IsWordChar)
  - [func bw(b *strings.Builder, args ...string)](#syntax-func-bw)
  - [func dumpProg(b *strings.Builder, p *Prog)](#syntax-func-dumpProg)
  - [func u32(i uint32) string](#syntax-func-u32)
  - [func dumpInst(b *strings.Builder, i *Inst)](#syntax-func-dumpInst)
  - [func writeRegexp(b *strings.Builder, re *Regexp)](#syntax-func-writeRegexp)
  - [func escape(b *strings.Builder, r rune, force bool)](#syntax-func-escape)
  - [func TestParseSimple(t *testing.T)](#syntax-func-TestParseSimple)
  - [func TestParseFoldCase(t *testing.T)](#syntax-func-TestParseFoldCase)
  - [func TestParseLiteral(t *testing.T)](#syntax-func-TestParseLiteral)
  - [func TestParseMatchNL(t *testing.T)](#syntax-func-TestParseMatchNL)
  - [func TestParseNoMatchNL(t *testing.T)](#syntax-func-TestParseNoMatchNL)
  - [func testParseDump(t *testing.T, tests []parseTest, flags Flags)](#syntax-func-testParseDump)
  - [func dump(re *Regexp) string](#syntax-func-dump)
  - [func dumpRegexp(b *strings.Builder, re *Regexp)](#syntax-func-dumpRegexp)
  - [func mkCharClass(f func(rune) bool) string](#syntax-func-mkCharClass)
  - [func isUpperFold(r rune) bool](#syntax-func-isUpperFold)
  - [func TestFoldConstants(t *testing.T)](#syntax-func-TestFoldConstants)
  - [func TestAppendRangeCollapse(t *testing.T)](#syntax-func-TestAppendRangeCollapse)
  - [func TestParseInvalidRegexps(t *testing.T)](#syntax-func-TestParseInvalidRegexps)
  - [func TestToStringEquivalentParse(t *testing.T)](#syntax-func-TestToStringEquivalentParse)
  - [func TestCompile(t *testing.T)](#syntax-func-TestCompile)
  - [func BenchmarkEmptyOpContext(b *testing.B)](#syntax-func-BenchmarkEmptyOpContext)
  - [func TestSimplify(t *testing.T)](#syntax-func-TestSimplify)

### <a name="syntax-const">Constants <small>(exported)</small></a>

#### <a name="syntax-const-_Op_name_0">const _Op_name_0</a>

```Go
const _Op_name_0 = "NoMatchEmptyMatchLiteralCharClassAnyCharNotNLAnyCharBeginLineEndLineBeginTextEndTextWordBoundaryNoWordBoundaryCaptureStarPlusQuestRepeatConcatAlternate"
```

#### <a name="syntax-const-_Op_name_1">const _Op_name_1</a>

```Go
const _Op_name_1 = "opPseudo"
```

#### <a name="syntax-const-ErrInternalError">const ErrInternalError <small>(exported)</small></a>

```Go
const ErrInternalError ErrorCode = "regexp/syntax: internal error"
```

Unexpected error 

#### <a name="syntax-const-ErrInvalidCharClass">const ErrInvalidCharClass <small>(exported)</small></a>

```Go
const ErrInvalidCharClass ErrorCode = "invalid character class"
```

Parse errors 

#### <a name="syntax-const-ErrInvalidCharRange">const ErrInvalidCharRange <small>(exported)</small></a>

```Go
const ErrInvalidCharRange ErrorCode = "invalid character class range"
```

#### <a name="syntax-const-ErrInvalidEscape">const ErrInvalidEscape <small>(exported)</small></a>

```Go
const ErrInvalidEscape ErrorCode = "invalid escape sequence"
```

#### <a name="syntax-const-ErrInvalidNamedCapture">const ErrInvalidNamedCapture <small>(exported)</small></a>

```Go
const ErrInvalidNamedCapture ErrorCode = "invalid named capture"
```

#### <a name="syntax-const-ErrInvalidPerlOp">const ErrInvalidPerlOp <small>(exported)</small></a>

```Go
const ErrInvalidPerlOp ErrorCode = "invalid or unsupported Perl syntax"
```

#### <a name="syntax-const-ErrInvalidRepeatOp">const ErrInvalidRepeatOp <small>(exported)</small></a>

```Go
const ErrInvalidRepeatOp ErrorCode = "invalid nested repetition operator"
```

#### <a name="syntax-const-ErrInvalidRepeatSize">const ErrInvalidRepeatSize <small>(exported)</small></a>

```Go
const ErrInvalidRepeatSize ErrorCode = "invalid repeat count"
```

#### <a name="syntax-const-ErrInvalidUTF8">const ErrInvalidUTF8 <small>(exported)</small></a>

```Go
const ErrInvalidUTF8 ErrorCode = "invalid UTF-8"
```

#### <a name="syntax-const-ErrMissingBracket">const ErrMissingBracket <small>(exported)</small></a>

```Go
const ErrMissingBracket ErrorCode = "missing closing ]"
```

#### <a name="syntax-const-ErrMissingParen">const ErrMissingParen <small>(exported)</small></a>

```Go
const ErrMissingParen ErrorCode = "missing closing )"
```

#### <a name="syntax-const-ErrMissingRepeatArgument">const ErrMissingRepeatArgument <small>(exported)</small></a>

```Go
const ErrMissingRepeatArgument ErrorCode = "missing argument to repetition operator"
```

#### <a name="syntax-const-ErrTrailingBackslash">const ErrTrailingBackslash <small>(exported)</small></a>

```Go
const ErrTrailingBackslash ErrorCode = "trailing backslash at end of expression"
```

#### <a name="syntax-const-ErrUnexpectedParen">const ErrUnexpectedParen <small>(exported)</small></a>

```Go
const ErrUnexpectedParen ErrorCode = "unexpected )"
```

#### <a name="syntax-const-FoldCase">const FoldCase <small>(exported)</small></a>

```Go
const FoldCase Flags = 1 << iota // case-insensitive match

```

#### <a name="syntax-const-Literal">const Literal <small>(exported)</small></a>

```Go
const Literal // treat pattern as literal string

```

#### <a name="syntax-const-ClassNL">const ClassNL <small>(exported)</small></a>

```Go
const ClassNL // allow character classes like [^a-z] and [[:space:]] to match newline

```

#### <a name="syntax-const-DotNL">const DotNL <small>(exported)</small></a>

```Go
const DotNL // allow . to match newline

```

#### <a name="syntax-const-OneLine">const OneLine <small>(exported)</small></a>

```Go
const OneLine // treat ^ and $ as only matching at beginning and end of text

```

#### <a name="syntax-const-NonGreedy">const NonGreedy <small>(exported)</small></a>

```Go
const NonGreedy // make repetition operators default to non-greedy

```

#### <a name="syntax-const-PerlX">const PerlX <small>(exported)</small></a>

```Go
const PerlX // allow Perl extensions

```

#### <a name="syntax-const-UnicodeGroups">const UnicodeGroups <small>(exported)</small></a>

```Go
const UnicodeGroups // allow \p{Han}, \P{Han} for Unicode group and negation

```

#### <a name="syntax-const-WasDollar">const WasDollar <small>(exported)</small></a>

```Go
const WasDollar // regexp OpEndText was $, not \z

```

#### <a name="syntax-const-Simple">const Simple <small>(exported)</small></a>

```Go
const Simple // regexp contains no counted repetition

```

#### <a name="syntax-const-MatchNL">const MatchNL <small>(exported)</small></a>

```Go
const MatchNL = ClassNL | DotNL
```

#### <a name="syntax-const-Perl">const Perl <small>(exported)</small></a>

```Go
const Perl = ClassNL | OneLine | PerlX | UnicodeGroups // as close to Perl as possible

```

#### <a name="syntax-const-POSIX">const POSIX <small>(exported)</small></a>

```Go
const POSIX Flags = 0 // POSIX syntax

```

#### <a name="syntax-const-opLeftParen">const opLeftParen</a>

```Go
const opLeftParen = opPseudo + iota
```

Pseudo-ops for parsing stack. 

#### <a name="syntax-const-opVerticalBar">const opVerticalBar</a>

```Go
const opVerticalBar
```

Pseudo-ops for parsing stack. 

#### <a name="syntax-const-minFold">const minFold</a>

```Go
const minFold = 0x0041
```

minimum and maximum runes involved in folding. checked during test. 

#### <a name="syntax-const-maxFold">const maxFold</a>

```Go
const maxFold = 0x1e943
```

#### <a name="syntax-const-InstAlt">const InstAlt <small>(exported)</small></a>

```Go
const InstAlt InstOp = iota
```

#### <a name="syntax-const-InstAltMatch">const InstAltMatch <small>(exported)</small></a>

```Go
const InstAltMatch
```

#### <a name="syntax-const-InstCapture">const InstCapture <small>(exported)</small></a>

```Go
const InstCapture
```

#### <a name="syntax-const-InstEmptyWidth">const InstEmptyWidth <small>(exported)</small></a>

```Go
const InstEmptyWidth
```

#### <a name="syntax-const-InstMatch">const InstMatch <small>(exported)</small></a>

```Go
const InstMatch
```

#### <a name="syntax-const-InstFail">const InstFail <small>(exported)</small></a>

```Go
const InstFail
```

#### <a name="syntax-const-InstNop">const InstNop <small>(exported)</small></a>

```Go
const InstNop
```

#### <a name="syntax-const-InstRune">const InstRune <small>(exported)</small></a>

```Go
const InstRune
```

#### <a name="syntax-const-InstRune1">const InstRune1 <small>(exported)</small></a>

```Go
const InstRune1
```

#### <a name="syntax-const-InstRuneAny">const InstRuneAny <small>(exported)</small></a>

```Go
const InstRuneAny
```

#### <a name="syntax-const-InstRuneAnyNotNL">const InstRuneAnyNotNL <small>(exported)</small></a>

```Go
const InstRuneAnyNotNL
```

#### <a name="syntax-const-EmptyBeginLine">const EmptyBeginLine <small>(exported)</small></a>

```Go
const EmptyBeginLine EmptyOp = 1 << iota
```

#### <a name="syntax-const-EmptyEndLine">const EmptyEndLine <small>(exported)</small></a>

```Go
const EmptyEndLine
```

#### <a name="syntax-const-EmptyBeginText">const EmptyBeginText <small>(exported)</small></a>

```Go
const EmptyBeginText
```

#### <a name="syntax-const-EmptyEndText">const EmptyEndText <small>(exported)</small></a>

```Go
const EmptyEndText
```

#### <a name="syntax-const-EmptyWordBoundary">const EmptyWordBoundary <small>(exported)</small></a>

```Go
const EmptyWordBoundary
```

#### <a name="syntax-const-EmptyNoWordBoundary">const EmptyNoWordBoundary <small>(exported)</small></a>

```Go
const EmptyNoWordBoundary
```

#### <a name="syntax-const-noMatch">const noMatch</a>

```Go
const noMatch = -1
```

#### <a name="syntax-const-OpNoMatch">const OpNoMatch <small>(exported)</small></a>

```Go
const OpNoMatch Op = 1 + iota // matches no strings

```

#### <a name="syntax-const-OpEmptyMatch">const OpEmptyMatch <small>(exported)</small></a>

```Go
const OpEmptyMatch // matches empty string

```

#### <a name="syntax-const-OpLiteral">const OpLiteral <small>(exported)</small></a>

```Go
const OpLiteral // matches Runes sequence

```

#### <a name="syntax-const-OpCharClass">const OpCharClass <small>(exported)</small></a>

```Go
const OpCharClass // matches Runes interpreted as range pair list

```

#### <a name="syntax-const-OpAnyCharNotNL">const OpAnyCharNotNL <small>(exported)</small></a>

```Go
const OpAnyCharNotNL // matches any character except newline

```

#### <a name="syntax-const-OpAnyChar">const OpAnyChar <small>(exported)</small></a>

```Go
const OpAnyChar // matches any character

```

#### <a name="syntax-const-OpBeginLine">const OpBeginLine <small>(exported)</small></a>

```Go
const OpBeginLine // matches empty string at beginning of line

```

#### <a name="syntax-const-OpEndLine">const OpEndLine <small>(exported)</small></a>

```Go
const OpEndLine // matches empty string at end of line

```

#### <a name="syntax-const-OpBeginText">const OpBeginText <small>(exported)</small></a>

```Go
const OpBeginText // matches empty string at beginning of text

```

#### <a name="syntax-const-OpEndText">const OpEndText <small>(exported)</small></a>

```Go
const OpEndText // matches empty string at end of text

```

#### <a name="syntax-const-OpWordBoundary">const OpWordBoundary <small>(exported)</small></a>

```Go
const OpWordBoundary // matches word boundary `\b`

```

#### <a name="syntax-const-OpNoWordBoundary">const OpNoWordBoundary <small>(exported)</small></a>

```Go
const OpNoWordBoundary // matches word non-boundary `\B`

```

#### <a name="syntax-const-OpCapture">const OpCapture <small>(exported)</small></a>

```Go
const OpCapture // capturing subexpression with index Cap, optional name Name

```

#### <a name="syntax-const-OpStar">const OpStar <small>(exported)</small></a>

```Go
const OpStar // matches Sub[0] zero or more times

```

#### <a name="syntax-const-OpPlus">const OpPlus <small>(exported)</small></a>

```Go
const OpPlus // matches Sub[0] one or more times

```

#### <a name="syntax-const-OpQuest">const OpQuest <small>(exported)</small></a>

```Go
const OpQuest // matches Sub[0] zero or one times

```

#### <a name="syntax-const-OpRepeat">const OpRepeat <small>(exported)</small></a>

```Go
const OpRepeat // matches Sub[0] at least Min times, at most Max (Max == -1 is no limit)

```

#### <a name="syntax-const-OpConcat">const OpConcat <small>(exported)</small></a>

```Go
const OpConcat // matches concatenation of Subs

```

#### <a name="syntax-const-OpAlternate">const OpAlternate <small>(exported)</small></a>

```Go
const OpAlternate // matches alternation of Subs

```

#### <a name="syntax-const-opPseudo">const opPseudo</a>

```Go
const opPseudo Op = 128 // where pseudo-ops start

```

#### <a name="syntax-const-meta">const meta</a>

```Go
const meta = `\.+*?()|[]{}^$`
```

#### <a name="syntax-const-testFlags">const testFlags</a>

```Go
const testFlags = MatchNL | PerlX | UnicodeGroups
```

### <a name="syntax-var">Variables <small>(exported)</small></a>

#### <a name="syntax-var-c">var c</a>

```Go
var c compiler
```

#### <a name="syntax-var-anyRuneNotNL">var anyRuneNotNL</a>

```Go
var anyRuneNotNL = ...
```

#### <a name="syntax-var-anyRune">var anyRune</a>

```Go
var anyRune = ...
```

#### <a name="syntax-var-f">var f</a>

```Go
var f frag
```

#### <a name="syntax-var-f">var f</a>

```Go
var f frag
```

#### <a name="syntax-var-f">var f</a>

```Go
var f frag
```

#### <a name="syntax-var-_Op_index_0">var _Op_index_0</a>

```Go
var _Op_index_0 = ...
```

#### <a name="syntax-var-str">var str</a>

```Go
var str []rune
```

Round 1: Factor out common literal prefixes. 

#### <a name="syntax-var-strflags">var strflags</a>

```Go
var strflags Flags
```

#### <a name="syntax-var-istr">var istr</a>

```Go
var istr []rune
```

Invariant: the Regexps that were in sub[0:start] have been used or marked for reuse, and the slice space has been reused for out (len(out) <= start). 

Invariant: sub[start:i] consists of regexps that all begin with str as modified by strflags. 

#### <a name="syntax-var-iflags">var iflags</a>

```Go
var iflags Flags
```

#### <a name="syntax-var-first">var first</a>

```Go
var first *Regexp
```

#### <a name="syntax-var-ifirst">var ifirst</a>

```Go
var ifirst *Regexp
```

Invariant: the Regexps that were in sub[0:start] have been used or marked for reuse, and the slice space has been reused for out (len(out) <= start). 

Invariant: sub[start:i] consists of regexps that all begin with ifirst. 

#### <a name="syntax-var-p">var p</a>

```Go
var p parser
```

Otherwise, must do real work. 

#### <a name="syntax-var-err">var err</a>

```Go
var err error
```

Otherwise, must do real work. 

#### <a name="syntax-var-c">var c</a>

```Go
var c rune
```

Otherwise, must do real work. 

#### <a name="syntax-var-op">var op</a>

```Go
var op Op
```

Otherwise, must do real work. 

#### <a name="syntax-var-lastRepeat">var lastRepeat</a>

```Go
var lastRepeat string
```

Otherwise, must do real work. 

#### <a name="syntax-var-lit">var lit</a>

```Go
var lit string
```

\Q ... \E: the ... is always literals 

#### <a name="syntax-var-ok1">var ok1</a>

```Go
var ok1 bool
```

#### <a name="syntax-var-c">var c</a>

```Go
var c rune
```

Non-capturing group. Might also twiddle Perl flags. 

#### <a name="syntax-var-anyTable">var anyTable</a>

```Go
var anyTable = ...
```

#### <a name="syntax-var-seq">var seq</a>

```Go
var seq, name string
```

#### <a name="syntax-var-name">var name</a>

```Go
var seq, name string
```

#### <a name="syntax-var-lo">var lo</a>

```Go
var lo, hi rune
```

#### <a name="syntax-var-hi">var hi</a>

```Go
var lo, hi rune
```

#### <a name="syntax-var-code1">var code1</a>

```Go
var code1 = ...
```

#### <a name="syntax-var-code2">var code2</a>

```Go
var code2 = ...
```

#### <a name="syntax-var-code3">var code3</a>

```Go
var code3 = ...
```

#### <a name="syntax-var-perlGroup">var perlGroup</a>

```Go
var perlGroup = ...
```

#### <a name="syntax-var-code4">var code4</a>

```Go
var code4 = ...
```

#### <a name="syntax-var-code5">var code5</a>

```Go
var code5 = ...
```

#### <a name="syntax-var-code6">var code6</a>

```Go
var code6 = ...
```

#### <a name="syntax-var-code7">var code7</a>

```Go
var code7 = ...
```

#### <a name="syntax-var-code8">var code8</a>

```Go
var code8 = ...
```

#### <a name="syntax-var-code9">var code9</a>

```Go
var code9 = ...
```

#### <a name="syntax-var-code10">var code10</a>

```Go
var code10 = ...
```

#### <a name="syntax-var-code11">var code11</a>

```Go
var code11 = ...
```

#### <a name="syntax-var-code12">var code12</a>

```Go
var code12 = ...
```

#### <a name="syntax-var-code13">var code13</a>

```Go
var code13 = ...
```

#### <a name="syntax-var-code14">var code14</a>

```Go
var code14 = ...
```

#### <a name="syntax-var-code15">var code15</a>

```Go
var code15 = ...
```

#### <a name="syntax-var-code16">var code16</a>

```Go
var code16 = ...
```

#### <a name="syntax-var-code17">var code17</a>

```Go
var code17 = ...
```

#### <a name="syntax-var-posixGroup">var posixGroup</a>

```Go
var posixGroup = ...
```

#### <a name="syntax-var-instOpNames">var instOpNames</a>

```Go
var instOpNames = ...
```

#### <a name="syntax-var-op">var op</a>

```Go
var op EmptyOp = EmptyNoWordBoundary
```

#### <a name="syntax-var-boundary">var boundary</a>

```Go
var boundary byte
```

#### <a name="syntax-var-b">var b</a>

```Go
var b strings.Builder
```

#### <a name="syntax-var-buf">var buf</a>

```Go
var buf strings.Builder
```

Have prefix; gather characters. 

#### <a name="syntax-var-flag">var flag</a>

```Go
var flag EmptyOp
```

#### <a name="syntax-var-b">var b</a>

```Go
var b strings.Builder
```

#### <a name="syntax-var-b">var b</a>

```Go
var b strings.Builder
```

#### <a name="syntax-var-prefix">var prefix</a>

```Go
var prefix *Regexp
```

Build leading prefix: xx. 

#### <a name="syntax-var-parseTests">var parseTests</a>

```Go
var parseTests = ...
```

#### <a name="syntax-var-foldcaseTests">var foldcaseTests</a>

```Go
var foldcaseTests = ...
```

#### <a name="syntax-var-literalTests">var literalTests</a>

```Go
var literalTests = ...
```

#### <a name="syntax-var-matchnlTests">var matchnlTests</a>

```Go
var matchnlTests = ...
```

#### <a name="syntax-var-nomatchnlTests">var nomatchnlTests</a>

```Go
var nomatchnlTests = ...
```

#### <a name="syntax-var-b">var b</a>

```Go
var b strings.Builder
```

#### <a name="syntax-var-opNames">var opNames</a>

```Go
var opNames = ...
```

#### <a name="syntax-var-r">var r</a>

```Go
var r []rune
```

AppendRange should collapse each of the new ranges into the earlier ones (it looks back two ranges), so that the slice never grows very large. Note that we are not calling cleanClass. 

#### <a name="syntax-var-invalidRegexps">var invalidRegexps</a>

```Go
var invalidRegexps = ...
```

#### <a name="syntax-var-onlyPerl">var onlyPerl</a>

```Go
var onlyPerl = ...
```

#### <a name="syntax-var-onlyPOSIX">var onlyPOSIX</a>

```Go
var onlyPOSIX = ...
```

#### <a name="syntax-var-compileTests">var compileTests</a>

```Go
var compileTests = ...
```

#### <a name="syntax-var-r1">var r1</a>

```Go
var r1 rune = -1
```

#### <a name="syntax-var-simplifyTests">var simplifyTests</a>

```Go
var simplifyTests = ...
```

### <a name="syntax-type">Types <small>(exported)</small></a>

#### <a name="syntax-type-patchList">type patchList struct</a>

```Go
type patchList struct {
	head, tail uint32
}
```

A patchList is a list of instruction pointers that need to be filled in (patched). Because the pointers haven't been filled in yet, we can reuse their storage to hold the list. It's kind of sleazy, but works well in practice. See [https://swtch.com/~rsc/regexp/regexp1.html](https://swtch.com/~rsc/regexp/regexp1.html) for inspiration. 

These aren't really pointers: they're integers, so we can reinterpret them this way without using package unsafe. A value l.head denotes p.inst[l.head>>1].Out (l.head&1==0) or .Arg (l.head&1==1). head == 0 denotes the empty list, okay because we start every program with a fail instruction, so we'll never want to point at its output link. 

##### <a name="syntax-type-patchList-makePatchList">func makePatchList(n uint32) patchList</a>

```Go
func makePatchList(n uint32) patchList
```

##### <a name="syntax-type-patchList-patch">func (l patchList) patch(p *Prog, val uint32)</a>

```Go
func (l patchList) patch(p *Prog, val uint32)
```

##### <a name="syntax-type-patchList-append">func (l1 patchList) append(p *Prog, l2 patchList) patchList</a>

```Go
func (l1 patchList) append(p *Prog, l2 patchList) patchList
```

#### <a name="syntax-type-frag">type frag struct</a>

```Go
type frag struct {
	i   uint32    // index of first instruction
	out patchList // where to record end instruction
}
```

A frag represents a compiled program fragment. 

#### <a name="syntax-type-compiler">type compiler struct</a>

```Go
type compiler struct {
	p *Prog
}
```

##### <a name="syntax-type-compiler-init">func (c *compiler) init()</a>

```Go
func (c *compiler) init()
```

##### <a name="syntax-type-compiler-compile">func (c *compiler) compile(re *Regexp) frag</a>

```Go
func (c *compiler) compile(re *Regexp) frag
```

##### <a name="syntax-type-compiler-inst">func (c *compiler) inst(op InstOp) frag</a>

```Go
func (c *compiler) inst(op InstOp) frag
```

##### <a name="syntax-type-compiler-nop">func (c *compiler) nop() frag</a>

```Go
func (c *compiler) nop() frag
```

##### <a name="syntax-type-compiler-fail">func (c *compiler) fail() frag</a>

```Go
func (c *compiler) fail() frag
```

##### <a name="syntax-type-compiler-cap">func (c *compiler) cap(arg uint32) frag</a>

```Go
func (c *compiler) cap(arg uint32) frag
```

##### <a name="syntax-type-compiler-cat">func (c *compiler) cat(f1, f2 frag) frag</a>

```Go
func (c *compiler) cat(f1, f2 frag) frag
```

##### <a name="syntax-type-compiler-alt">func (c *compiler) alt(f1, f2 frag) frag</a>

```Go
func (c *compiler) alt(f1, f2 frag) frag
```

##### <a name="syntax-type-compiler-quest">func (c *compiler) quest(f1 frag, nongreedy bool) frag</a>

```Go
func (c *compiler) quest(f1 frag, nongreedy bool) frag
```

##### <a name="syntax-type-compiler-star">func (c *compiler) star(f1 frag, nongreedy bool) frag</a>

```Go
func (c *compiler) star(f1 frag, nongreedy bool) frag
```

##### <a name="syntax-type-compiler-plus">func (c *compiler) plus(f1 frag, nongreedy bool) frag</a>

```Go
func (c *compiler) plus(f1 frag, nongreedy bool) frag
```

##### <a name="syntax-type-compiler-empty">func (c *compiler) empty(op EmptyOp) frag</a>

```Go
func (c *compiler) empty(op EmptyOp) frag
```

##### <a name="syntax-type-compiler-rune">func (c *compiler) rune(r []rune, flags Flags) frag</a>

```Go
func (c *compiler) rune(r []rune, flags Flags) frag
```

#### <a name="syntax-type-Error">type Error struct <small>(exported)</small></a>

```Go
type Error struct {
	Code ErrorCode
	Expr string
}
```

An Error describes a failure to parse a regular expression and gives the offending expression. 

##### <a name="syntax-type-Error-Error">func (e *Error) Error() string <small>(exported)</small></a>

```Go
func (e *Error) Error() string
```

#### <a name="syntax-type-ErrorCode">type ErrorCode string <small>(exported)</small></a>

```Go
type ErrorCode string
```

An ErrorCode describes a failure to parse a regular expression. 

##### <a name="syntax-type-ErrorCode-String">func (e ErrorCode) String() string <small>(exported)</small></a>

```Go
func (e ErrorCode) String() string
```

#### <a name="syntax-type-Flags">type Flags uint16 <small>(exported)</small></a>

```Go
type Flags uint16
```

Flags control the behavior of the parser and record information about regexp context. 

#### <a name="syntax-type-parser">type parser struct</a>

```Go
type parser struct {
	flags       Flags     // parse mode flags
	stack       []*Regexp // stack of parsed expressions
	free        *Regexp
	numCap      int // number of capturing groups seen
	wholeRegexp string
	tmpClass    []rune // temporary char class work space
}
```

##### <a name="syntax-type-parser-newRegexp">func (p *parser) newRegexp(op Op) *Regexp</a>

```Go
func (p *parser) newRegexp(op Op) *Regexp
```

##### <a name="syntax-type-parser-reuse">func (p *parser) reuse(re *Regexp)</a>

```Go
func (p *parser) reuse(re *Regexp)
```

##### <a name="syntax-type-parser-push">func (p *parser) push(re *Regexp) *Regexp</a>

```Go
func (p *parser) push(re *Regexp) *Regexp
```

push pushes the regexp re onto the parse stack and returns the regexp. 

##### <a name="syntax-type-parser-maybeConcat">func (p *parser) maybeConcat(r rune, flags Flags) bool</a>

```Go
func (p *parser) maybeConcat(r rune, flags Flags) bool
```

maybeConcat implements incremental concatenation of literal runes into string nodes. The parser calls this before each push, so only the top fragment of the stack might need processing. Since this is called before a push, the topmost literal is no longer subject to operators like * (Otherwise ab* would turn into (ab)*.) If r >= 0 and there's a node left over, maybeConcat uses it to push r with the given flags. maybeConcat reports whether r was pushed. 

##### <a name="syntax-type-parser-literal">func (p *parser) literal(r rune)</a>

```Go
func (p *parser) literal(r rune)
```

literal pushes a literal regexp for the rune r on the stack. 

##### <a name="syntax-type-parser-op">func (p *parser) op(op Op) *Regexp</a>

```Go
func (p *parser) op(op Op) *Regexp
```

op pushes a regexp with the given op onto the stack and returns that regexp. 

##### <a name="syntax-type-parser-repeat">func (p *parser) repeat(op Op, min, max int, before, after, lastRepeat string) (string, error)</a>

```Go
func (p *parser) repeat(op Op, min, max int, before, after, lastRepeat string) (string, error)
```

repeat replaces the top stack element with itself repeated according to op, min, max. before is the regexp suffix starting at the repetition operator. after is the regexp suffix following after the repetition operator. repeat returns an updated 'after' and an error, if any. 

##### <a name="syntax-type-parser-concat">func (p *parser) concat() *Regexp</a>

```Go
func (p *parser) concat() *Regexp
```

concat replaces the top of the stack (above the topmost '|' or '(') with its concatenation. 

##### <a name="syntax-type-parser-alternate">func (p *parser) alternate() *Regexp</a>

```Go
func (p *parser) alternate() *Regexp
```

alternate replaces the top of the stack (above the topmost '(') with its alternation. 

##### <a name="syntax-type-parser-collapse">func (p *parser) collapse(subs []*Regexp, op Op) *Regexp</a>

```Go
func (p *parser) collapse(subs []*Regexp, op Op) *Regexp
```

collapse returns the result of applying op to sub. If sub contains op nodes, they all get hoisted up so that there is never a concat of a concat or an alternate of an alternate. 

##### <a name="syntax-type-parser-factor">func (p *parser) factor(sub []*Regexp) []*Regexp</a>

```Go
func (p *parser) factor(sub []*Regexp) []*Regexp
```

factor factors common prefixes from the alternation list sub. It returns a replacement list that reuses the same storage and frees (passes to p.reuse) any removed *Regexps. 

For example, 

```
ABC|ABD|AEF|BCX|BCY

```
simplifies by literal prefix extraction to 

```
A(B(C|D)|EF)|BC(X|Y)

```
which simplifies by character class introduction to 

```
A(B[CD]|EF)|BC[XY]

```
##### <a name="syntax-type-parser-leadingString">func (p *parser) leadingString(re *Regexp) ([]rune, Flags)</a>

```Go
func (p *parser) leadingString(re *Regexp) ([]rune, Flags)
```

leadingString returns the leading literal string that re begins with. The string refers to storage in re or its children. 

##### <a name="syntax-type-parser-removeLeadingString">func (p *parser) removeLeadingString(re *Regexp, n int) *Regexp</a>

```Go
func (p *parser) removeLeadingString(re *Regexp, n int) *Regexp
```

removeLeadingString removes the first n leading runes from the beginning of re. It returns the replacement for re. 

##### <a name="syntax-type-parser-leadingRegexp">func (p *parser) leadingRegexp(re *Regexp) *Regexp</a>

```Go
func (p *parser) leadingRegexp(re *Regexp) *Regexp
```

leadingRegexp returns the leading regexp that re begins with. The regexp refers to storage in re or its children. 

##### <a name="syntax-type-parser-removeLeadingRegexp">func (p *parser) removeLeadingRegexp(re *Regexp, reuse bool) *Regexp</a>

```Go
func (p *parser) removeLeadingRegexp(re *Regexp, reuse bool) *Regexp
```

removeLeadingRegexp removes the leading regexp in re. It returns the replacement for re. If reuse is true, it passes the removed regexp (if no longer needed) to p.reuse. 

##### <a name="syntax-type-parser-parseRepeat">func (p *parser) parseRepeat(s string) (min, max int, rest string, ok bool)</a>

```Go
func (p *parser) parseRepeat(s string) (min, max int, rest string, ok bool)
```

parseRepeat parses {min} (max=min) or {min,} (max=-1) or {min,max}. If s is not of that form, it returns ok == false. If s has the right form but the values are too big, it returns min == -1, ok == true. 

##### <a name="syntax-type-parser-parsePerlFlags">func (p *parser) parsePerlFlags(s string) (rest string, err error)</a>

```Go
func (p *parser) parsePerlFlags(s string) (rest string, err error)
```

parsePerlFlags parses a Perl flag setting or non-capturing group or both, like (?i) or (?: or (?i:.  It removes the prefix from s and updates the parse state. The caller must have ensured that s begins with "(?". 

##### <a name="syntax-type-parser-parseInt">func (p *parser) parseInt(s string) (n int, rest string, ok bool)</a>

```Go
func (p *parser) parseInt(s string) (n int, rest string, ok bool)
```

parseInt parses a decimal integer. 

##### <a name="syntax-type-parser-parseVerticalBar">func (p *parser) parseVerticalBar() error</a>

```Go
func (p *parser) parseVerticalBar() error
```

parseVerticalBar handles a | in the input. 

##### <a name="syntax-type-parser-swapVerticalBar">func (p *parser) swapVerticalBar() bool</a>

```Go
func (p *parser) swapVerticalBar() bool
```

If the top of the stack is an element followed by an opVerticalBar swapVerticalBar swaps the two and returns true. Otherwise it returns false. 

##### <a name="syntax-type-parser-parseRightParen">func (p *parser) parseRightParen() error</a>

```Go
func (p *parser) parseRightParen() error
```

parseRightParen handles a ) in the input. 

##### <a name="syntax-type-parser-parseEscape">func (p *parser) parseEscape(s string) (r rune, rest string, err error)</a>

```Go
func (p *parser) parseEscape(s string) (r rune, rest string, err error)
```

parseEscape parses an escape sequence at the beginning of s and returns the rune. 

##### <a name="syntax-type-parser-parseClassChar">func (p *parser) parseClassChar(s, wholeClass string) (r rune, rest string, err error)</a>

```Go
func (p *parser) parseClassChar(s, wholeClass string) (r rune, rest string, err error)
```

parseClassChar parses a character class character at the beginning of s and returns it. 

##### <a name="syntax-type-parser-parsePerlClassEscape">func (p *parser) parsePerlClassEscape(s string, r []rune) (out []rune, rest string)</a>

```Go
func (p *parser) parsePerlClassEscape(s string, r []rune) (out []rune, rest string)
```

parsePerlClassEscape parses a leading Perl character class escape like \d from the beginning of s. If one is present, it appends the characters to r and returns the new slice r and the remainder of the string. 

##### <a name="syntax-type-parser-parseNamedClass">func (p *parser) parseNamedClass(s string, r []rune) (out []rune, rest string, err error)</a>

```Go
func (p *parser) parseNamedClass(s string, r []rune) (out []rune, rest string, err error)
```

parseNamedClass parses a leading POSIX named character class like [:alnum:] from the beginning of s. If one is present, it appends the characters to r and returns the new slice r and the remainder of the string. 

##### <a name="syntax-type-parser-appendGroup">func (p *parser) appendGroup(r []rune, g charGroup) []rune</a>

```Go
func (p *parser) appendGroup(r []rune, g charGroup) []rune
```

##### <a name="syntax-type-parser-parseUnicodeClass">func (p *parser) parseUnicodeClass(s string, r []rune) (out []rune, rest string, err error)</a>

```Go
func (p *parser) parseUnicodeClass(s string, r []rune) (out []rune, rest string, err error)
```

parseUnicodeClass parses a leading Unicode character class like \p{Han} from the beginning of s. If one is present, it appends the characters to r and returns the new slice r and the remainder of the string. 

##### <a name="syntax-type-parser-parseClass">func (p *parser) parseClass(s string) (rest string, err error)</a>

```Go
func (p *parser) parseClass(s string) (rest string, err error)
```

parseClass parses a character class at the beginning of s and pushes it onto the parse stack. 

#### <a name="syntax-type-charGroup">type charGroup struct</a>

```Go
type charGroup struct {
	sign  int
	class []rune
}
```

#### <a name="syntax-type-ranges">type ranges struct</a>

```Go
type ranges struct {
	p *[]rune
}
```

ranges implements sort.Interface on a []rune. The choice of receiver type definition is strange but avoids an allocation since we already have a *[]rune. 

##### <a name="syntax-type-ranges-Less">func (ra ranges) Less(i, j int) bool</a>

```Go
func (ra ranges) Less(i, j int) bool
```

##### <a name="syntax-type-ranges-Len">func (ra ranges) Len() int</a>

```Go
func (ra ranges) Len() int
```

##### <a name="syntax-type-ranges-Swap">func (ra ranges) Swap(i, j int)</a>

```Go
func (ra ranges) Swap(i, j int)
```

#### <a name="syntax-type-Prog">type Prog struct <small>(exported)</small></a>

```Go
type Prog struct {
	Inst   []Inst
	Start  int // index of start instruction
	NumCap int // number of InstCapture insts in re
}
```

A Prog is a compiled regular expression program. 

##### <a name="syntax-type-Prog-Compile">func Compile(re *Regexp) (*Prog, error) <small>(exported)</small></a>

```Go
func Compile(re *Regexp) (*Prog, error)
```

Compile compiles the regexp into a program to be executed. The regexp should have been simplified already (returned from re.Simplify). 

##### <a name="syntax-type-Prog-String">func (p *Prog) String() string <small>(exported)</small></a>

```Go
func (p *Prog) String() string
```

##### <a name="syntax-type-Prog-skipNop">func (p *Prog) skipNop(pc uint32) *Inst</a>

```Go
func (p *Prog) skipNop(pc uint32) *Inst
```

skipNop follows any no-op or capturing instructions. 

##### <a name="syntax-type-Prog-Prefix">func (p *Prog) Prefix() (prefix string, complete bool) <small>(exported)</small></a>

```Go
func (p *Prog) Prefix() (prefix string, complete bool)
```

Prefix returns a literal string that all matches for the regexp must start with. Complete is true if the prefix is the entire match. 

##### <a name="syntax-type-Prog-StartCond">func (p *Prog) StartCond() EmptyOp <small>(exported)</small></a>

```Go
func (p *Prog) StartCond() EmptyOp
```

StartCond returns the leading empty-width conditions that must be true in any match. It returns ^EmptyOp(0) if no matches are possible. 

#### <a name="syntax-type-InstOp">type InstOp uint8 <small>(exported)</small></a>

```Go
type InstOp uint8
```

An InstOp is an instruction opcode. 

##### <a name="syntax-type-InstOp-String">func (i InstOp) String() string <small>(exported)</small></a>

```Go
func (i InstOp) String() string
```

#### <a name="syntax-type-EmptyOp">type EmptyOp uint8 <small>(exported)</small></a>

```Go
type EmptyOp uint8
```

An EmptyOp specifies a kind or mixture of zero-width assertions. 

##### <a name="syntax-type-EmptyOp-EmptyOpContext">func EmptyOpContext(r1, r2 rune) EmptyOp <small>(exported)</small></a>

```Go
func EmptyOpContext(r1, r2 rune) EmptyOp
```

EmptyOpContext returns the zero-width assertions satisfied at the position between the runes r1 and r2. Passing r1 == -1 indicates that the position is at the beginning of the text. Passing r2 == -1 indicates that the position is at the end of the text. 

#### <a name="syntax-type-Inst">type Inst struct <small>(exported)</small></a>

```Go
type Inst struct {
	Op   InstOp
	Out  uint32 // all but InstMatch, InstFail
	Arg  uint32 // InstAlt, InstAltMatch, InstCapture, InstEmptyWidth
	Rune []rune
}
```

An Inst is a single instruction in a regular expression program. 

##### <a name="syntax-type-Inst-op">func (i *Inst) op() InstOp</a>

```Go
func (i *Inst) op() InstOp
```

op returns i.Op but merges all the Rune special cases into InstRune 

##### <a name="syntax-type-Inst-MatchRune">func (i *Inst) MatchRune(r rune) bool <small>(exported)</small></a>

```Go
func (i *Inst) MatchRune(r rune) bool
```

MatchRune reports whether the instruction matches (and consumes) r. It should only be called when i.Op == InstRune. 

##### <a name="syntax-type-Inst-MatchRunePos">func (i *Inst) MatchRunePos(r rune) int <small>(exported)</small></a>

```Go
func (i *Inst) MatchRunePos(r rune) int
```

MatchRunePos checks whether the instruction matches (and consumes) r. If so, MatchRunePos returns the index of the matching rune pair (or, when len(i.Rune) == 1, rune singleton). If not, MatchRunePos returns -1. MatchRunePos should only be called when i.Op == InstRune. 

##### <a name="syntax-type-Inst-MatchEmptyWidth">func (i *Inst) MatchEmptyWidth(before rune, after rune) bool <small>(exported)</small></a>

```Go
func (i *Inst) MatchEmptyWidth(before rune, after rune) bool
```

MatchEmptyWidth reports whether the instruction matches an empty string between the runes before and after. It should only be called when i.Op == InstEmptyWidth. 

##### <a name="syntax-type-Inst-String">func (i *Inst) String() string <small>(exported)</small></a>

```Go
func (i *Inst) String() string
```

#### <a name="syntax-type-Regexp">type Regexp struct <small>(exported)</small></a>

```Go
type Regexp struct {
	Op       Op // operator
	Flags    Flags
	Sub      []*Regexp  // subexpressions, if any
	Sub0     [1]*Regexp // storage for short Sub
	Rune     []rune     // matched runes, for OpLiteral, OpCharClass
	Rune0    [2]rune    // storage for short Rune
	Min, Max int        // min, max for OpRepeat
	Cap      int        // capturing index, for OpCapture
	Name     string     // capturing name, for OpCapture
}
```

A Regexp is a node in a regular expression syntax tree. 

##### <a name="syntax-type-Regexp-literalRegexp">func literalRegexp(s string, flags Flags) *Regexp</a>

```Go
func literalRegexp(s string, flags Flags) *Regexp
```

##### <a name="syntax-type-Regexp-Parse">func Parse(s string, flags Flags) (*Regexp, error) <small>(exported)</small></a>

```Go
func Parse(s string, flags Flags) (*Regexp, error)
```

Parse parses a regular expression string s, controlled by the specified Flags, and returns a regular expression parse tree. The syntax is described in the top-level comment. 

##### <a name="syntax-type-Regexp-simplify1">func simplify1(op Op, flags Flags, sub, re *Regexp) *Regexp</a>

```Go
func simplify1(op Op, flags Flags, sub, re *Regexp) *Regexp
```

simplify1 implements Simplify for the unary OpStar, OpPlus, and OpQuest operators. It returns the simple regexp equivalent to 

```
Regexp{Op: op, Flags: flags, Sub: {sub}}

```
under the assumption that sub is already simple, and without first allocating that structure. If the regexp to be returned turns out to be equivalent to re, simplify1 returns re instead. 

simplify1 is factored out of Simplify because the implementation for other operators generates these unary expressions. Letting them call simplify1 makes sure the expressions they generate are simple. 

##### <a name="syntax-type-Regexp-Equal">func (x *Regexp) Equal(y *Regexp) bool <small>(exported)</small></a>

```Go
func (x *Regexp) Equal(y *Regexp) bool
```

Equal reports whether x and y have identical structure. 

##### <a name="syntax-type-Regexp-String">func (re *Regexp) String() string <small>(exported)</small></a>

```Go
func (re *Regexp) String() string
```

##### <a name="syntax-type-Regexp-MaxCap">func (re *Regexp) MaxCap() int <small>(exported)</small></a>

```Go
func (re *Regexp) MaxCap() int
```

MaxCap walks the regexp to find the maximum capture index. 

##### <a name="syntax-type-Regexp-CapNames">func (re *Regexp) CapNames() []string <small>(exported)</small></a>

```Go
func (re *Regexp) CapNames() []string
```

CapNames walks the regexp to find the names of capturing groups. 

##### <a name="syntax-type-Regexp-capNames">func (re *Regexp) capNames(names []string)</a>

```Go
func (re *Regexp) capNames(names []string)
```

##### <a name="syntax-type-Regexp-Simplify">func (re *Regexp) Simplify() *Regexp <small>(exported)</small></a>

```Go
func (re *Regexp) Simplify() *Regexp
```

Simplify returns a regexp equivalent to re but without counted repetitions and with various other simplifications, such as rewriting /(?:a+)+/ to /a+/. The resulting regexp will execute correctly but its string representation will not produce the same parse tree, because capturing parentheses may have been duplicated or removed. For example, the simplified form for /(x){1,2}/ is /(x)(x)?/ but both parentheses capture as $1. The returned regexp may share structure with or be the original. 

#### <a name="syntax-type-Op">type Op uint8 <small>(exported)</small></a>

```Go
type Op uint8
```

An Op is a single regular expression operator. 

##### <a name="syntax-type-Op-String">func (i Op) String() string <small>(exported)</small></a>

```Go
func (i Op) String() string
```

#### <a name="syntax-type-parseTest">type parseTest struct</a>

```Go
type parseTest struct {
	Regexp string
	Dump   string
}
```

### <a name="syntax-func">Functions <small>(exported)</small></a>

#### <a name="syntax-func-minFoldRune">func minFoldRune(r rune) rune</a>

```Go
func minFoldRune(r rune) rune
```

minFoldRune returns the minimum rune fold-equivalent to r. 

#### <a name="syntax-func-repeatIsValid">func repeatIsValid(re *Regexp, n int) bool</a>

```Go
func repeatIsValid(re *Regexp, n int) bool
```

repeatIsValid reports whether the repetition re is valid. Valid means that the combination of the top-level repetition and any inner repetitions does not exceed n copies of the innermost thing. This function rewalks the regexp tree and is called for every repetition, so we have to worry about inducing quadratic behavior in the parser. We avoid this by only calling repeatIsValid when min or max >= 2. In that case the depth of any >= 2 nesting can only get to 9 without triggering a parse error, so each subtree can only be rewalked 9 times. 

#### <a name="syntax-func-cleanAlt">func cleanAlt(re *Regexp)</a>

```Go
func cleanAlt(re *Regexp)
```

cleanAlt cleans re for eventual inclusion in an alternation. 

#### <a name="syntax-func-isValidCaptureName">func isValidCaptureName(name string) bool</a>

```Go
func isValidCaptureName(name string) bool
```

isValidCaptureName reports whether name is a valid capture name: [A-Za-z0-9_]+. PCRE limits names to 32 bytes. Python rejects names starting with digits. We don't enforce either of those. 

#### <a name="syntax-func-isCharClass">func isCharClass(re *Regexp) bool</a>

```Go
func isCharClass(re *Regexp) bool
```

can this be represented as a character class? single-rune literal string, char class, ., and .|\n. 

#### <a name="syntax-func-matchRune">func matchRune(re *Regexp, r rune) bool</a>

```Go
func matchRune(re *Regexp, r rune) bool
```

does re match r? 

#### <a name="syntax-func-mergeCharClass">func mergeCharClass(dst, src *Regexp)</a>

```Go
func mergeCharClass(dst, src *Regexp)
```

mergeCharClass makes dst = dst|src. The caller must ensure that dst.Op >= src.Op, to reduce the amount of copying. 

#### <a name="syntax-func-unicodeTable">func unicodeTable(name string) (*unicode.RangeTable, *unicode.RangeTable)</a>

```Go
func unicodeTable(name string) (*unicode.RangeTable, *unicode.RangeTable)
```

unicodeTable returns the unicode.RangeTable identified by name and the table of additional fold-equivalent code points. 

#### <a name="syntax-func-cleanClass">func cleanClass(rp *[]rune) []rune</a>

```Go
func cleanClass(rp *[]rune) []rune
```

cleanClass sorts the ranges (pairs of elements of r), merges them, and eliminates duplicates. 

#### <a name="syntax-func-appendLiteral">func appendLiteral(r []rune, x rune, flags Flags) []rune</a>

```Go
func appendLiteral(r []rune, x rune, flags Flags) []rune
```

appendLiteral returns the result of appending the literal x to the class r. 

#### <a name="syntax-func-appendRange">func appendRange(r []rune, lo, hi rune) []rune</a>

```Go
func appendRange(r []rune, lo, hi rune) []rune
```

appendRange returns the result of appending the range lo-hi to the class r. 

#### <a name="syntax-func-appendFoldedRange">func appendFoldedRange(r []rune, lo, hi rune) []rune</a>

```Go
func appendFoldedRange(r []rune, lo, hi rune) []rune
```

appendFoldedRange returns the result of appending the range lo-hi and its case folding-equivalent runes to the class r. 

#### <a name="syntax-func-appendClass">func appendClass(r []rune, x []rune) []rune</a>

```Go
func appendClass(r []rune, x []rune) []rune
```

appendClass returns the result of appending the class x to the class r. It assume x is clean. 

#### <a name="syntax-func-appendFoldedClass">func appendFoldedClass(r []rune, x []rune) []rune</a>

```Go
func appendFoldedClass(r []rune, x []rune) []rune
```

appendFolded returns the result of appending the case folding of the class x to the class r. 

#### <a name="syntax-func-appendNegatedClass">func appendNegatedClass(r []rune, x []rune) []rune</a>

```Go
func appendNegatedClass(r []rune, x []rune) []rune
```

appendNegatedClass returns the result of appending the negation of the class x to the class r. It assumes x is clean. 

#### <a name="syntax-func-appendTable">func appendTable(r []rune, x *unicode.RangeTable) []rune</a>

```Go
func appendTable(r []rune, x *unicode.RangeTable) []rune
```

appendTable returns the result of appending x to the class r. 

#### <a name="syntax-func-appendNegatedTable">func appendNegatedTable(r []rune, x *unicode.RangeTable) []rune</a>

```Go
func appendNegatedTable(r []rune, x *unicode.RangeTable) []rune
```

appendNegatedTable returns the result of appending the negation of x to the class r. 

#### <a name="syntax-func-negateClass">func negateClass(r []rune) []rune</a>

```Go
func negateClass(r []rune) []rune
```

negateClass overwrites r and returns r's negation. It assumes the class r is already clean. 

#### <a name="syntax-func-checkUTF8">func checkUTF8(s string) error</a>

```Go
func checkUTF8(s string) error
```

#### <a name="syntax-func-nextRune">func nextRune(s string) (c rune, t string, err error)</a>

```Go
func nextRune(s string) (c rune, t string, err error)
```

#### <a name="syntax-func-isalnum">func isalnum(c rune) bool</a>

```Go
func isalnum(c rune) bool
```

#### <a name="syntax-func-unhex">func unhex(c rune) rune</a>

```Go
func unhex(c rune) rune
```

#### <a name="syntax-func-IsWordChar">func IsWordChar(r rune) bool <small>(exported)</small></a>

```Go
func IsWordChar(r rune) bool
```

IsWordChar reports whether r is consider a `word character' during the evaluation of the \b and \B zero-width assertions. These assertions are ASCII-only: the word characters are [A-Za-z0-9_]. 

#### <a name="syntax-func-bw">func bw(b *strings.Builder, args ...string)</a>

```Go
func bw(b *strings.Builder, args ...string)
```

#### <a name="syntax-func-dumpProg">func dumpProg(b *strings.Builder, p *Prog)</a>

```Go
func dumpProg(b *strings.Builder, p *Prog)
```

#### <a name="syntax-func-u32">func u32(i uint32) string</a>

```Go
func u32(i uint32) string
```

#### <a name="syntax-func-dumpInst">func dumpInst(b *strings.Builder, i *Inst)</a>

```Go
func dumpInst(b *strings.Builder, i *Inst)
```

#### <a name="syntax-func-writeRegexp">func writeRegexp(b *strings.Builder, re *Regexp)</a>

```Go
func writeRegexp(b *strings.Builder, re *Regexp)
```

writeRegexp writes the Perl syntax for the regular expression re to b. 

#### <a name="syntax-func-escape">func escape(b *strings.Builder, r rune, force bool)</a>

```Go
func escape(b *strings.Builder, r rune, force bool)
```

#### <a name="syntax-func-TestParseSimple">func TestParseSimple(t *testing.T)</a>

```Go
func TestParseSimple(t *testing.T)
```

#### <a name="syntax-func-TestParseFoldCase">func TestParseFoldCase(t *testing.T)</a>

```Go
func TestParseFoldCase(t *testing.T)
```

#### <a name="syntax-func-TestParseLiteral">func TestParseLiteral(t *testing.T)</a>

```Go
func TestParseLiteral(t *testing.T)
```

#### <a name="syntax-func-TestParseMatchNL">func TestParseMatchNL(t *testing.T)</a>

```Go
func TestParseMatchNL(t *testing.T)
```

#### <a name="syntax-func-TestParseNoMatchNL">func TestParseNoMatchNL(t *testing.T)</a>

```Go
func TestParseNoMatchNL(t *testing.T)
```

#### <a name="syntax-func-testParseDump">func testParseDump(t *testing.T, tests []parseTest, flags Flags)</a>

```Go
func testParseDump(t *testing.T, tests []parseTest, flags Flags)
```

Test Parse -> Dump. 

#### <a name="syntax-func-dump">func dump(re *Regexp) string</a>

```Go
func dump(re *Regexp) string
```

dump prints a string representation of the regexp showing the structure explicitly. 

#### <a name="syntax-func-dumpRegexp">func dumpRegexp(b *strings.Builder, re *Regexp)</a>

```Go
func dumpRegexp(b *strings.Builder, re *Regexp)
```

dumpRegexp writes an encoding of the syntax tree for the regexp re to b. It is used during testing to distinguish between parses that might print the same using re's String method. 

#### <a name="syntax-func-mkCharClass">func mkCharClass(f func(rune) bool) string</a>

```Go
func mkCharClass(f func(rune) bool) string
```

#### <a name="syntax-func-isUpperFold">func isUpperFold(r rune) bool</a>

```Go
func isUpperFold(r rune) bool
```

#### <a name="syntax-func-TestFoldConstants">func TestFoldConstants(t *testing.T)</a>

```Go
func TestFoldConstants(t *testing.T)
```

#### <a name="syntax-func-TestAppendRangeCollapse">func TestAppendRangeCollapse(t *testing.T)</a>

```Go
func TestAppendRangeCollapse(t *testing.T)
```

#### <a name="syntax-func-TestParseInvalidRegexps">func TestParseInvalidRegexps(t *testing.T)</a>

```Go
func TestParseInvalidRegexps(t *testing.T)
```

#### <a name="syntax-func-TestToStringEquivalentParse">func TestToStringEquivalentParse(t *testing.T)</a>

```Go
func TestToStringEquivalentParse(t *testing.T)
```

#### <a name="syntax-func-TestCompile">func TestCompile(t *testing.T)</a>

```Go
func TestCompile(t *testing.T)
```

#### <a name="syntax-func-BenchmarkEmptyOpContext">func BenchmarkEmptyOpContext(b *testing.B)</a>

```Go
func BenchmarkEmptyOpContext(b *testing.B)
```

#### <a name="syntax-func-TestSimplify">func TestSimplify(t *testing.T)</a>

```Go
func TestSimplify(t *testing.T)
```

## <a name="regexp_test">Package regexp_test <small>(new page)</small></a>

## Index

- [Variables](#regexp_test-var)
  - [var validID](#regexp_test-var-validID)
- [Functions](#regexp_test-func)
  - [func Example()](#regexp_test-func-Example)
  - [func ExampleMatch()](#regexp_test-func-ExampleMatch)
  - [func ExampleMatchString()](#regexp_test-func-ExampleMatchString)
  - [func ExampleQuoteMeta()](#regexp_test-func-ExampleQuoteMeta)
  - [func ExampleRegexp_Find()](#regexp_test-func-ExampleRegexp_Find)
  - [func ExampleRegexp_FindAll()](#regexp_test-func-ExampleRegexp_FindAll)
  - [func ExampleRegexp_FindAllSubmatch()](#regexp_test-func-ExampleRegexp_FindAllSubmatch)
  - [func ExampleRegexp_FindSubmatch()](#regexp_test-func-ExampleRegexp_FindSubmatch)
  - [func ExampleRegexp_Match()](#regexp_test-func-ExampleRegexp_Match)
  - [func ExampleRegexp_FindString()](#regexp_test-func-ExampleRegexp_FindString)
  - [func ExampleRegexp_FindStringIndex()](#regexp_test-func-ExampleRegexp_FindStringIndex)
  - [func ExampleRegexp_FindStringSubmatch()](#regexp_test-func-ExampleRegexp_FindStringSubmatch)
  - [func ExampleRegexp_FindAllString()](#regexp_test-func-ExampleRegexp_FindAllString)
  - [func ExampleRegexp_FindAllStringSubmatch()](#regexp_test-func-ExampleRegexp_FindAllStringSubmatch)
  - [func ExampleRegexp_FindAllStringSubmatchIndex()](#regexp_test-func-ExampleRegexp_FindAllStringSubmatchIndex)
  - [func ExampleRegexp_FindSubmatchIndex()](#regexp_test-func-ExampleRegexp_FindSubmatchIndex)
  - [func ExampleRegexp_Longest()](#regexp_test-func-ExampleRegexp_Longest)
  - [func ExampleRegexp_MatchString()](#regexp_test-func-ExampleRegexp_MatchString)
  - [func ExampleRegexp_NumSubexp()](#regexp_test-func-ExampleRegexp_NumSubexp)
  - [func ExampleRegexp_ReplaceAll()](#regexp_test-func-ExampleRegexp_ReplaceAll)
  - [func ExampleRegexp_ReplaceAllLiteralString()](#regexp_test-func-ExampleRegexp_ReplaceAllLiteralString)
  - [func ExampleRegexp_ReplaceAllString()](#regexp_test-func-ExampleRegexp_ReplaceAllString)
  - [func ExampleRegexp_ReplaceAllStringFunc()](#regexp_test-func-ExampleRegexp_ReplaceAllStringFunc)
  - [func ExampleRegexp_SubexpNames()](#regexp_test-func-ExampleRegexp_SubexpNames)
  - [func ExampleRegexp_SubexpIndex()](#regexp_test-func-ExampleRegexp_SubexpIndex)
  - [func ExampleRegexp_Split()](#regexp_test-func-ExampleRegexp_Split)
  - [func ExampleRegexp_Expand()](#regexp_test-func-ExampleRegexp_Expand)
  - [func ExampleRegexp_ExpandString()](#regexp_test-func-ExampleRegexp_ExpandString)
  - [func ExampleRegexp_FindIndex()](#regexp_test-func-ExampleRegexp_FindIndex)
  - [func ExampleRegexp_FindAllSubmatchIndex()](#regexp_test-func-ExampleRegexp_FindAllSubmatchIndex)
  - [func ExampleRegexp_FindAllIndex()](#regexp_test-func-ExampleRegexp_FindAllIndex)

### <a name="regexp_test-var">Variables</a>

#### <a name="regexp_test-var-validID">var validID</a>

```Go
var validID = regexp.MustCompile(`^[a-z]+\[[0-9]+\]$`)
```

Compile the expression once, usually at init time. Use raw strings to avoid having to quote the backslashes. 

### <a name="regexp_test-func">Functions</a>

#### <a name="regexp_test-func-Example">func Example()</a>

```Go
func Example()
```

#### <a name="regexp_test-func-ExampleMatch">func ExampleMatch()</a>

```Go
func ExampleMatch()
```

#### <a name="regexp_test-func-ExampleMatchString">func ExampleMatchString()</a>

```Go
func ExampleMatchString()
```

#### <a name="regexp_test-func-ExampleQuoteMeta">func ExampleQuoteMeta()</a>

```Go
func ExampleQuoteMeta()
```

#### <a name="regexp_test-func-ExampleRegexp_Find">func ExampleRegexp_Find()</a>

```Go
func ExampleRegexp_Find()
```

#### <a name="regexp_test-func-ExampleRegexp_FindAll">func ExampleRegexp_FindAll()</a>

```Go
func ExampleRegexp_FindAll()
```

#### <a name="regexp_test-func-ExampleRegexp_FindAllSubmatch">func ExampleRegexp_FindAllSubmatch()</a>

```Go
func ExampleRegexp_FindAllSubmatch()
```

#### <a name="regexp_test-func-ExampleRegexp_FindSubmatch">func ExampleRegexp_FindSubmatch()</a>

```Go
func ExampleRegexp_FindSubmatch()
```

#### <a name="regexp_test-func-ExampleRegexp_Match">func ExampleRegexp_Match()</a>

```Go
func ExampleRegexp_Match()
```

#### <a name="regexp_test-func-ExampleRegexp_FindString">func ExampleRegexp_FindString()</a>

```Go
func ExampleRegexp_FindString()
```

#### <a name="regexp_test-func-ExampleRegexp_FindStringIndex">func ExampleRegexp_FindStringIndex()</a>

```Go
func ExampleRegexp_FindStringIndex()
```

#### <a name="regexp_test-func-ExampleRegexp_FindStringSubmatch">func ExampleRegexp_FindStringSubmatch()</a>

```Go
func ExampleRegexp_FindStringSubmatch()
```

#### <a name="regexp_test-func-ExampleRegexp_FindAllString">func ExampleRegexp_FindAllString()</a>

```Go
func ExampleRegexp_FindAllString()
```

#### <a name="regexp_test-func-ExampleRegexp_FindAllStringSubmatch">func ExampleRegexp_FindAllStringSubmatch()</a>

```Go
func ExampleRegexp_FindAllStringSubmatch()
```

#### <a name="regexp_test-func-ExampleRegexp_FindAllStringSubmatchIndex">func ExampleRegexp_FindAllStringSubmatchIndex()</a>

```Go
func ExampleRegexp_FindAllStringSubmatchIndex()
```

#### <a name="regexp_test-func-ExampleRegexp_FindSubmatchIndex">func ExampleRegexp_FindSubmatchIndex()</a>

```Go
func ExampleRegexp_FindSubmatchIndex()
```

#### <a name="regexp_test-func-ExampleRegexp_Longest">func ExampleRegexp_Longest()</a>

```Go
func ExampleRegexp_Longest()
```

#### <a name="regexp_test-func-ExampleRegexp_MatchString">func ExampleRegexp_MatchString()</a>

```Go
func ExampleRegexp_MatchString()
```

#### <a name="regexp_test-func-ExampleRegexp_NumSubexp">func ExampleRegexp_NumSubexp()</a>

```Go
func ExampleRegexp_NumSubexp()
```

#### <a name="regexp_test-func-ExampleRegexp_ReplaceAll">func ExampleRegexp_ReplaceAll()</a>

```Go
func ExampleRegexp_ReplaceAll()
```

#### <a name="regexp_test-func-ExampleRegexp_ReplaceAllLiteralString">func ExampleRegexp_ReplaceAllLiteralString()</a>

```Go
func ExampleRegexp_ReplaceAllLiteralString()
```

#### <a name="regexp_test-func-ExampleRegexp_ReplaceAllString">func ExampleRegexp_ReplaceAllString()</a>

```Go
func ExampleRegexp_ReplaceAllString()
```

#### <a name="regexp_test-func-ExampleRegexp_ReplaceAllStringFunc">func ExampleRegexp_ReplaceAllStringFunc()</a>

```Go
func ExampleRegexp_ReplaceAllStringFunc()
```

#### <a name="regexp_test-func-ExampleRegexp_SubexpNames">func ExampleRegexp_SubexpNames()</a>

```Go
func ExampleRegexp_SubexpNames()
```

#### <a name="regexp_test-func-ExampleRegexp_SubexpIndex">func ExampleRegexp_SubexpIndex()</a>

```Go
func ExampleRegexp_SubexpIndex()
```

#### <a name="regexp_test-func-ExampleRegexp_Split">func ExampleRegexp_Split()</a>

```Go
func ExampleRegexp_Split()
```

#### <a name="regexp_test-func-ExampleRegexp_Expand">func ExampleRegexp_Expand()</a>

```Go
func ExampleRegexp_Expand()
```

#### <a name="regexp_test-func-ExampleRegexp_ExpandString">func ExampleRegexp_ExpandString()</a>

```Go
func ExampleRegexp_ExpandString()
```

#### <a name="regexp_test-func-ExampleRegexp_FindIndex">func ExampleRegexp_FindIndex()</a>

```Go
func ExampleRegexp_FindIndex()
```

#### <a name="regexp_test-func-ExampleRegexp_FindAllSubmatchIndex">func ExampleRegexp_FindAllSubmatchIndex()</a>

```Go
func ExampleRegexp_FindAllSubmatchIndex()
```

#### <a name="regexp_test-func-ExampleRegexp_FindAllIndex">func ExampleRegexp_FindAllIndex()</a>

```Go
func ExampleRegexp_FindAllIndex()
```

